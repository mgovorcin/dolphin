{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dolphin Documentation Table Of Contents Getting started Tutorials How-To Guides Code Reference Background theory","title":"Dolphin Documentation"},{"location":"#dolphin-documentation","text":"","title":"Dolphin Documentation"},{"location":"#table-of-contents","text":"Getting started Tutorials How-To Guides Code Reference Background theory","title":"Table Of Contents"},{"location":"background-theory/","text":"","title":"Background theory"},{"location":"getting-started/","text":"Install The following will install dolphin into a conda environment. Download source code: git clone https://github.com/opera-adt/dolphin.git && cd dolphin Install dependencies: # assuming that mamba is installed: https://mamba.readthedocs.io/en/latest/ # if not, start with: # conda install mamba -n base -c conda-forge mamba install -c conda-forge --file requirements.txt Install dolphin via pip: # -e installs in development mode python -m pip install -e . For development: # run \"pip install -e\" to install with extra development requirements python -m pip install -e .[docs] # Get pre-commit hooks so that linting/formatting is done automatically pre-commit install # After making changes, check the tests: pytest Creating Documentation We use MKDocs to generate the documentation. The reference documentation is generated from the code docstrings using mkdocstrings . When adding new documentation, you can build and serve the documentation locally using: mkdocs serve then open http://localhost:8000 in your browser. Creating new files or updating existing files will automatically trigger a rebuild of the documentation while mkdocs serve is running. The online documentation is hosted using Github Pages and versioned using Mike . Manually deploying new versions (copied from https://github.com/squidfunk/mkdocs-material-example-versioning) Make a change to docs/index.md, and publish the first version: mike deploy --push --update-aliases 0.1 latest Set the default version to latest mike set-default --push latest","title":"Getting started"},{"location":"getting-started/#install","text":"The following will install dolphin into a conda environment. Download source code: git clone https://github.com/opera-adt/dolphin.git && cd dolphin Install dependencies: # assuming that mamba is installed: https://mamba.readthedocs.io/en/latest/ # if not, start with: # conda install mamba -n base -c conda-forge mamba install -c conda-forge --file requirements.txt Install dolphin via pip: # -e installs in development mode python -m pip install -e . For development: # run \"pip install -e\" to install with extra development requirements python -m pip install -e .[docs] # Get pre-commit hooks so that linting/formatting is done automatically pre-commit install # After making changes, check the tests: pytest","title":"Install"},{"location":"getting-started/#creating-documentation","text":"We use MKDocs to generate the documentation. The reference documentation is generated from the code docstrings using mkdocstrings . When adding new documentation, you can build and serve the documentation locally using: mkdocs serve then open http://localhost:8000 in your browser. Creating new files or updating existing files will automatically trigger a rebuild of the documentation while mkdocs serve is running. The online documentation is hosted using Github Pages and versioned using Mike .","title":"Creating Documentation"},{"location":"getting-started/#manually-deploying-new-versions","text":"(copied from https://github.com/squidfunk/mkdocs-material-example-versioning) Make a change to docs/index.md, and publish the first version: mike deploy --push --update-aliases 0.1 latest Set the default version to latest mike set-default --push latest","title":"Manually deploying new versions"},{"location":"how-to-guides/","text":"","title":"How to guides"},{"location":"tutorials/","text":"This part of the project documentation will contain step-by-step instructions for learning about generating displacement using Dolphin.","title":"Tutorials"},{"location":"reference/summary/","text":"dolphin _log _show_versions cli utils version workflows cli config config_yml s1_disp_stack","title":"Summary"},{"location":"reference/dolphin/","text":"","title":"dolphin"},{"location":"reference/dolphin/_log/","text":"Exports a get_log function which sets up easy logging. Uses the standard python logging utilities, just provides nice formatting out of the box across multiple files. Usage: from ._log import get_log logger = get_log() logger.info(\"Something happened\") logger.warning(\"Something concerning happened\") logger.error(\"Something bad happened\") logger.critical(\"Something just awful happened\") logger.debug(\"Extra printing we often don't need to see.\") # Custom output for this module: logger.success(\"Something great happened: highlight this success\") format_log ( logger , debug = False ) Make the logging output pretty and colored with times. Parameters: Name Type Description Default logger logging . Logger The logger to format required debug bool (Default value If true, sets logging level to DEBUG False Returns: Type Description logging . Logger Source code in dolphin/_log.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def format_log ( logger , debug = False ): \"\"\"Make the logging output pretty and colored with times. Parameters ---------- logger : logging.Logger The logger to format debug : bool (Default value = False) If true, sets logging level to DEBUG Returns ------- logging.Logger \"\"\" log_level = logging . DEBUG if debug else logging . INFO format_ = \"[ %(asctime)s ] [ %(levelname)s %(filename)s ] %(message)s \" formatter = Formatter ( format_ , datefmt = \"%m/ %d %H:%M:%S\" ) handler = logging . StreamHandler () handler . setFormatter ( formatter ) if not logger . handlers : logger . addHandler ( handler ) logger . setLevel ( log_level ) if debug : logger . setLevel ( debug ) return logger get_log ( debug = False , name = 'dolphin.log' ) Create a nice log format for use across multiple files. Default logging level is INFO Parameters: Name Type Description Default name Optional [ str ] The name the logger will use when printing statements (Default value = \"dolphin.log\") 'dolphin.log' debug Optional [ bool ] If true, sets logging level to DEBUG (Default value = False) False Returns: Type Description logging . Logger Source code in dolphin/_log.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def get_log ( debug = False , name = \"dolphin.log\" ): \"\"\"Create a nice log format for use across multiple files. Default logging level is INFO Parameters ---------- name : Optional[str] The name the logger will use when printing statements (Default value = \"dolphin.log\") debug : Optional[bool] If true, sets logging level to DEBUG (Default value = False) Returns ------- logging.Logger \"\"\" logger = logging . getLogger ( name ) return format_log ( logger , debug = debug ) log_runtime ( f ) Decorate a function to time how long it takes to run. Usage @log_runtime def test_func(): return 2 + 4 Source code in dolphin/_log.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def log_runtime ( f ): \"\"\"Decorate a function to time how long it takes to run. Usage ----- @log_runtime def test_func(): return 2 + 4 \"\"\" logger = get_log () def wrapper ( * args , ** kwargs ): t1 = time . time () result = f ( * args , ** kwargs ) t2 = time . time () elapsed_time = t2 - t1 time_string = \"Total elapsed time for {} : {} minutes ( {} seconds)\" . format ( f . __name__ , \" {0:.2f} \" . format ( elapsed_time / 60.0 ), \" {0:.2f} \" . format ( elapsed_time ), ) logger . info ( time_string ) return result return wrapper","title":"_log"},{"location":"reference/dolphin/_log/#dolphin._log.format_log","text":"Make the logging output pretty and colored with times. Parameters: Name Type Description Default logger logging . Logger The logger to format required debug bool (Default value If true, sets logging level to DEBUG False Returns: Type Description logging . Logger Source code in dolphin/_log.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def format_log ( logger , debug = False ): \"\"\"Make the logging output pretty and colored with times. Parameters ---------- logger : logging.Logger The logger to format debug : bool (Default value = False) If true, sets logging level to DEBUG Returns ------- logging.Logger \"\"\" log_level = logging . DEBUG if debug else logging . INFO format_ = \"[ %(asctime)s ] [ %(levelname)s %(filename)s ] %(message)s \" formatter = Formatter ( format_ , datefmt = \"%m/ %d %H:%M:%S\" ) handler = logging . StreamHandler () handler . setFormatter ( formatter ) if not logger . handlers : logger . addHandler ( handler ) logger . setLevel ( log_level ) if debug : logger . setLevel ( debug ) return logger","title":"format_log()"},{"location":"reference/dolphin/_log/#dolphin._log.get_log","text":"Create a nice log format for use across multiple files. Default logging level is INFO Parameters: Name Type Description Default name Optional [ str ] The name the logger will use when printing statements (Default value = \"dolphin.log\") 'dolphin.log' debug Optional [ bool ] If true, sets logging level to DEBUG (Default value = False) False Returns: Type Description logging . Logger Source code in dolphin/_log.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def get_log ( debug = False , name = \"dolphin.log\" ): \"\"\"Create a nice log format for use across multiple files. Default logging level is INFO Parameters ---------- name : Optional[str] The name the logger will use when printing statements (Default value = \"dolphin.log\") debug : Optional[bool] If true, sets logging level to DEBUG (Default value = False) Returns ------- logging.Logger \"\"\" logger = logging . getLogger ( name ) return format_log ( logger , debug = debug )","title":"get_log()"},{"location":"reference/dolphin/_log/#dolphin._log.log_runtime","text":"Decorate a function to time how long it takes to run.","title":"log_runtime()"},{"location":"reference/dolphin/_log/#dolphin._log.log_runtime--usage","text":"@log_runtime def test_func(): return 2 + 4 Source code in dolphin/_log.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def log_runtime ( f ): \"\"\"Decorate a function to time how long it takes to run. Usage ----- @log_runtime def test_func(): return 2 + 4 \"\"\" logger = get_log () def wrapper ( * args , ** kwargs ): t1 = time . time () result = f ( * args , ** kwargs ) t2 = time . time () elapsed_time = t2 - t1 time_string = \"Total elapsed time for {} : {} minutes ( {} seconds)\" . format ( f . __name__ , \" {0:.2f} \" . format ( elapsed_time / 60.0 ), \" {0:.2f} \" . format ( elapsed_time ), ) logger . info ( time_string ) return result return wrapper","title":"Usage"},{"location":"reference/dolphin/_show_versions/","text":"Utility methods to print system info for debugging. Adapted from rasterio.show_versions , which was adapted from sklearn.utils._show_versions which was adapted from pandas.show_versions show_versions () Print useful debugging information. Examples: python -c \"import dolphin; dolphin.show_versions()\" Source code in dolphin/_show_versions.py 91 92 93 94 95 96 97 98 99 100 101 102 103 def show_versions (): \"\"\"Print useful debugging information. Examples -------- > python -c \"import dolphin; dolphin.show_versions()\" \"\"\" print ( \"dolphin info:\" ) _print_info_dict ( _get_opera_info ()) print ( \" \\n System:\" ) _print_info_dict ( _get_sys_info ()) print ( \" \\n Python deps:\" ) _print_info_dict ( _get_deps_info ())","title":"_show_versions"},{"location":"reference/dolphin/_show_versions/#dolphin._show_versions.show_versions","text":"Print useful debugging information. Examples: python -c \"import dolphin; dolphin.show_versions()\" Source code in dolphin/_show_versions.py 91 92 93 94 95 96 97 98 99 100 101 102 103 def show_versions (): \"\"\"Print useful debugging information. Examples -------- > python -c \"import dolphin; dolphin.show_versions()\" \"\"\" print ( \"dolphin info:\" ) _print_info_dict ( _get_opera_info ()) print ( \" \\n System:\" ) _print_info_dict ( _get_sys_info ()) print ( \" \\n Python deps:\" ) _print_info_dict ( _get_deps_info ())","title":"show_versions()"},{"location":"reference/dolphin/cli/","text":"main () Top-level command line interface to the workflows. Source code in dolphin/cli.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def main (): \"\"\"Top-level command line interface to the workflows.\"\"\" import dolphin.workflows.cli import dolphin.workflows.config parser = argparse . ArgumentParser ( prog = __package__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) subparser = parser . add_subparsers ( title = \"subcommands\" ) # Adds the subcommand to the top-level parser _ = dolphin . workflows . cli . get_parser ( subparser , \"run\" ) _ = dolphin . workflows . config . get_parser ( subparser , \"config\" ) # return p.parse_args() return parser . parse_args ()","title":"cli"},{"location":"reference/dolphin/cli/#dolphin.cli.main","text":"Top-level command line interface to the workflows. Source code in dolphin/cli.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def main (): \"\"\"Top-level command line interface to the workflows.\"\"\" import dolphin.workflows.cli import dolphin.workflows.config parser = argparse . ArgumentParser ( prog = __package__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) subparser = parser . add_subparsers ( title = \"subcommands\" ) # Adds the subcommand to the top-level parser _ = dolphin . workflows . cli . get_parser ( subparser , \"run\" ) _ = dolphin . workflows . config . get_parser ( subparser , \"config\" ) # return p.parse_args() return parser . parse_args ()","title":"main()"},{"location":"reference/dolphin/utils/","text":"gdal_to_numpy_type ( gdal_type ) Convert gdal type to numpy type. Source code in dolphin/utils.py 30 31 32 33 34 def gdal_to_numpy_type ( gdal_type ): \"\"\"Convert gdal type to numpy type.\"\"\" if isinstance ( gdal_type , str ): gdal_type = gdal . GetDataTypeByName ( gdal_type ) return gdal_array . GDALTypeCodeToNumericTypeCode ( gdal_type ) get_dates ( filename ) Search for dates (YYYYMMDD) in filename , excluding path. Source code in dolphin/utils.py 37 38 39 40 41 42 43 44 def get_dates ( filename : Filename ) -> List [ Union [ None , str ]]: \"\"\"Search for dates (YYYYMMDD) in `filename`, excluding path.\"\"\" date_list = re . findall ( r \"\\d {4} \\d {2} \\d {2} \" , Path ( filename ) . stem ) if not date_list : msg = f \" { filename } does not contain date as YYYYMMDD\" logger . warning ( msg ) # raise ValueError(msg) return date_list numpy_to_gdal_type ( np_dtype ) Convert numpy dtype to gdal type. Source code in dolphin/utils.py 17 18 19 20 21 22 23 24 25 26 27 def numpy_to_gdal_type ( np_dtype ): \"\"\"Convert numpy dtype to gdal type.\"\"\" # Wrap in np.dtype in case string is passed if isinstance ( np_dtype , str ): np_dtype = np . dtype ( np_dtype . lower ()) elif isinstance ( np_dtype , type ): np_dtype = np . dtype ( np_dtype ) if np . issubdtype ( bool , np_dtype ): return gdalconst . GDT_Byte return gdal_array . NumericTypeCodeToGDALTypeCode ( np_dtype ) parse_slc_strings ( slc_str , fmt = '%Y%m %d ' ) Parse a string, or list of strings, matching fmt into datetime.date. Parameters: Name Type Description Default slc_str str or list of str String or list of strings to parse. required fmt str , optional Format of string to parse. Default is \"%Y%m%d\". '%Y%m%d' Returns: Type Description datetime.date, or list of datetime.date Source code in dolphin/utils.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def parse_slc_strings ( slc_str : Union [ Filename , List [ Filename ]], fmt = \"%Y%m %d \" ): \"\"\"Parse a string, or list of strings, matching `fmt` into datetime.date. Parameters ---------- slc_str : str or list of str String or list of strings to parse. fmt : str, optional Format of string to parse. Default is \"%Y%m%d\". Returns ------- datetime.date, or list of datetime.date \"\"\" def _parse ( datestr , fmt = \"%Y%m %d \" ) -> datetime . date : return datetime . datetime . strptime ( datestr , fmt ) . date () # The re.search will find YYYYMMDD anywhere in string if isinstance ( slc_str , str ) or hasattr ( slc_str , \"__fspath__\" ): d_str = get_dates ( slc_str ) if not d_str : raise ValueError ( f \"Could not find date of format { fmt } in { slc_str } \" ) # return None return _parse ( d_str [ 0 ], fmt = fmt ) else : # If it's an iterable of strings, run on each one return [ parse_slc_strings ( s , fmt = fmt ) for s in slc_str if s ]","title":"utils"},{"location":"reference/dolphin/utils/#dolphin.utils.gdal_to_numpy_type","text":"Convert gdal type to numpy type. Source code in dolphin/utils.py 30 31 32 33 34 def gdal_to_numpy_type ( gdal_type ): \"\"\"Convert gdal type to numpy type.\"\"\" if isinstance ( gdal_type , str ): gdal_type = gdal . GetDataTypeByName ( gdal_type ) return gdal_array . GDALTypeCodeToNumericTypeCode ( gdal_type )","title":"gdal_to_numpy_type()"},{"location":"reference/dolphin/utils/#dolphin.utils.get_dates","text":"Search for dates (YYYYMMDD) in filename , excluding path. Source code in dolphin/utils.py 37 38 39 40 41 42 43 44 def get_dates ( filename : Filename ) -> List [ Union [ None , str ]]: \"\"\"Search for dates (YYYYMMDD) in `filename`, excluding path.\"\"\" date_list = re . findall ( r \"\\d {4} \\d {2} \\d {2} \" , Path ( filename ) . stem ) if not date_list : msg = f \" { filename } does not contain date as YYYYMMDD\" logger . warning ( msg ) # raise ValueError(msg) return date_list","title":"get_dates()"},{"location":"reference/dolphin/utils/#dolphin.utils.numpy_to_gdal_type","text":"Convert numpy dtype to gdal type. Source code in dolphin/utils.py 17 18 19 20 21 22 23 24 25 26 27 def numpy_to_gdal_type ( np_dtype ): \"\"\"Convert numpy dtype to gdal type.\"\"\" # Wrap in np.dtype in case string is passed if isinstance ( np_dtype , str ): np_dtype = np . dtype ( np_dtype . lower ()) elif isinstance ( np_dtype , type ): np_dtype = np . dtype ( np_dtype ) if np . issubdtype ( bool , np_dtype ): return gdalconst . GDT_Byte return gdal_array . NumericTypeCodeToGDALTypeCode ( np_dtype )","title":"numpy_to_gdal_type()"},{"location":"reference/dolphin/utils/#dolphin.utils.parse_slc_strings","text":"Parse a string, or list of strings, matching fmt into datetime.date. Parameters: Name Type Description Default slc_str str or list of str String or list of strings to parse. required fmt str , optional Format of string to parse. Default is \"%Y%m%d\". '%Y%m%d' Returns: Type Description datetime.date, or list of datetime.date Source code in dolphin/utils.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def parse_slc_strings ( slc_str : Union [ Filename , List [ Filename ]], fmt = \"%Y%m %d \" ): \"\"\"Parse a string, or list of strings, matching `fmt` into datetime.date. Parameters ---------- slc_str : str or list of str String or list of strings to parse. fmt : str, optional Format of string to parse. Default is \"%Y%m%d\". Returns ------- datetime.date, or list of datetime.date \"\"\" def _parse ( datestr , fmt = \"%Y%m %d \" ) -> datetime . date : return datetime . datetime . strptime ( datestr , fmt ) . date () # The re.search will find YYYYMMDD anywhere in string if isinstance ( slc_str , str ) or hasattr ( slc_str , \"__fspath__\" ): d_str = get_dates ( slc_str ) if not d_str : raise ValueError ( f \"Could not find date of format { fmt } in { slc_str } \" ) # return None return _parse ( d_str [ 0 ], fmt = fmt ) else : # If it's an iterable of strings, run on each one return [ parse_slc_strings ( s , fmt = fmt ) for s in slc_str if s ]","title":"parse_slc_strings()"},{"location":"reference/dolphin/version/","text":"","title":"version"},{"location":"reference/dolphin/workflows/","text":"Tools for creating workflows and running displacement workflows.","title":"workflows"},{"location":"reference/dolphin/workflows/cli/","text":"get_parser ( subparser = None , subcommand_name = 'run' ) Set up the command line interface. Source code in dolphin/workflows/cli.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def get_parser ( subparser = None , subcommand_name = \"run\" ): \"\"\"Set up the command line interface.\"\"\" metadata = dict ( description = \"Run a displacement workflow\" , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) if subparser : # Used by the subparser to make a nested command line interface parser = subparser . add_parser ( subcommand_name , ** metadata ) else : parser = argparse . ArgumentParser ( ** metadata ) parser . add_argument ( \"config_file\" , help = \"Name of YAML configuration file describing workflow options.\" , ) parser . add_argument ( \"-n\" , \"--name\" , default = \"stack\" , choices = [ \"single\" , \"stack\" ], help = \"Name workflow to run.\" , ) parser . add_argument ( \"--debug\" , action = \"store_true\" , help = \"Print debug messages to the log.\" , ) return parser main () Get the command line arguments and run the workflow. Source code in dolphin/workflows/cli.py 68 69 70 71 72 def main (): \"\"\"Get the command line arguments and run the workflow.\"\"\" parser = get_parser () args = parser . parse_args () run ( args . config_file , name = args . name , debug = args . debug ) run ( config_file , name = 'stack' , debug = False ) Run the displacement workflow. Parameters: Name Type Description Default config_file str YAML file containing the workflow options. required name str , choices Name of the workflow to run. 'stack' debug bool , optional Enable debug logging, by default False. False Source code in dolphin/workflows/cli.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @log_runtime def run ( config_file : str , name : str = \"stack\" , debug : bool = False ): \"\"\"Run the displacement workflow. Parameters ---------- config_file : str YAML file containing the workflow options. name : str, choices = [\"single\", \"stack\"] Name of the workflow to run. debug : bool, optional Enable debug logging, by default False. \"\"\" cfg = config . load_workflow_yaml ( config_file , workflow_name = f \"s1_disp_ { name } \" ) cfg_path = Path ( config_file ) filled_cfg_path = cfg_path . with_name ( cfg_path . stem + \"_filled\" + cfg_path . suffix ) config . save_yaml ( filled_cfg_path , config . add_dolphin_section ( cfg )) if name == \"single\" : # from dolphin.workflows import s1_disp_single # TODO raise NotImplementedError ( \"Single interferogram workflow not yet implemented\" ) elif name == \"stack\" : from dolphin.workflows import s1_disp_stack s1_disp_stack . run ( cfg [ \"runconfig\" ][ \"groups\" ], debug = debug )","title":"cli"},{"location":"reference/dolphin/workflows/cli/#dolphin.workflows.cli.get_parser","text":"Set up the command line interface. Source code in dolphin/workflows/cli.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def get_parser ( subparser = None , subcommand_name = \"run\" ): \"\"\"Set up the command line interface.\"\"\" metadata = dict ( description = \"Run a displacement workflow\" , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) if subparser : # Used by the subparser to make a nested command line interface parser = subparser . add_parser ( subcommand_name , ** metadata ) else : parser = argparse . ArgumentParser ( ** metadata ) parser . add_argument ( \"config_file\" , help = \"Name of YAML configuration file describing workflow options.\" , ) parser . add_argument ( \"-n\" , \"--name\" , default = \"stack\" , choices = [ \"single\" , \"stack\" ], help = \"Name workflow to run.\" , ) parser . add_argument ( \"--debug\" , action = \"store_true\" , help = \"Print debug messages to the log.\" , ) return parser","title":"get_parser()"},{"location":"reference/dolphin/workflows/cli/#dolphin.workflows.cli.main","text":"Get the command line arguments and run the workflow. Source code in dolphin/workflows/cli.py 68 69 70 71 72 def main (): \"\"\"Get the command line arguments and run the workflow.\"\"\" parser = get_parser () args = parser . parse_args () run ( args . config_file , name = args . name , debug = args . debug )","title":"main()"},{"location":"reference/dolphin/workflows/cli/#dolphin.workflows.cli.run","text":"Run the displacement workflow. Parameters: Name Type Description Default config_file str YAML file containing the workflow options. required name str , choices Name of the workflow to run. 'stack' debug bool , optional Enable debug logging, by default False. False Source code in dolphin/workflows/cli.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @log_runtime def run ( config_file : str , name : str = \"stack\" , debug : bool = False ): \"\"\"Run the displacement workflow. Parameters ---------- config_file : str YAML file containing the workflow options. name : str, choices = [\"single\", \"stack\"] Name of the workflow to run. debug : bool, optional Enable debug logging, by default False. \"\"\" cfg = config . load_workflow_yaml ( config_file , workflow_name = f \"s1_disp_ { name } \" ) cfg_path = Path ( config_file ) filled_cfg_path = cfg_path . with_name ( cfg_path . stem + \"_filled\" + cfg_path . suffix ) config . save_yaml ( filled_cfg_path , config . add_dolphin_section ( cfg )) if name == \"single\" : # from dolphin.workflows import s1_disp_single # TODO raise NotImplementedError ( \"Single interferogram workflow not yet implemented\" ) elif name == \"stack\" : from dolphin.workflows import s1_disp_stack s1_disp_stack . run ( cfg [ \"runconfig\" ][ \"groups\" ], debug = debug )","title":"run()"},{"location":"reference/dolphin/workflows/config/","text":"Config Bases: BaseModel Configuration for the workflow. Source code in dolphin/workflows/config.py 68 69 70 71 class Config ( BaseModel ): \"\"\"Configuration for the workflow.\"\"\" input_files : InputFiles ExtraFileGroup Bases: BaseModel Holds the location of extra files needed for processing. Source code in dolphin/workflows/config.py 27 28 29 30 31 32 33 34 35 class ExtraFileGroup ( BaseModel ): \"\"\"Holds the location of extra files needed for processing.\"\"\" # \"dynamic__file_group\" mask_files : List [ str ] = Field ( default_factory = list , description = \"List of mask files\" ) amp_disp_file : str = Field ( None , description = \"Amplitude dispersion file\" ) amp_mean_file : str = Field ( None , description = \"Amplitude mean file\" ) Settings Bases: BaseSettings Settings configurable based on environment variables. Source code in dolphin/workflows/config.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Settings ( BaseSettings ): \"\"\"Settings configurable based on environment variables.\"\"\" # https://docs.pydantic.dev/usage/settings/#parsing-environment-variable-values # If one is available, enable processing on GPU gpu_enabled : bool = True # Index of the GPU to use for processing, optional. Defaults to the # first available CUDA device. Ignored if *gpu_enabled* is False. gpu_id : int = 0 # Number of cpu cores to use for processing (if CPU). Default 16 n_workers : int = PositiveInt ( 16 ) class Config : env_prefix = \"dolphin_\" # e.g. DOLPHIN_N_WORKERS=4 for n_workers fields = { \"gpu_enabled\" : { \"env\" : [ \"gpu_enabled\" , \"gpu\" ]}, }","title":"config"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.Config","text":"Bases: BaseModel Configuration for the workflow. Source code in dolphin/workflows/config.py 68 69 70 71 class Config ( BaseModel ): \"\"\"Configuration for the workflow.\"\"\" input_files : InputFiles","title":"Config"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.ExtraFileGroup","text":"Bases: BaseModel Holds the location of extra files needed for processing. Source code in dolphin/workflows/config.py 27 28 29 30 31 32 33 34 35 class ExtraFileGroup ( BaseModel ): \"\"\"Holds the location of extra files needed for processing.\"\"\" # \"dynamic__file_group\" mask_files : List [ str ] = Field ( default_factory = list , description = \"List of mask files\" ) amp_disp_file : str = Field ( None , description = \"Amplitude dispersion file\" ) amp_mean_file : str = Field ( None , description = \"Amplitude mean file\" )","title":"ExtraFileGroup"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.Settings","text":"Bases: BaseSettings Settings configurable based on environment variables. Source code in dolphin/workflows/config.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Settings ( BaseSettings ): \"\"\"Settings configurable based on environment variables.\"\"\" # https://docs.pydantic.dev/usage/settings/#parsing-environment-variable-values # If one is available, enable processing on GPU gpu_enabled : bool = True # Index of the GPU to use for processing, optional. Defaults to the # first available CUDA device. Ignored if *gpu_enabled* is False. gpu_id : int = 0 # Number of cpu cores to use for processing (if CPU). Default 16 n_workers : int = PositiveInt ( 16 ) class Config : env_prefix = \"dolphin_\" # e.g. DOLPHIN_N_WORKERS=4 for n_workers fields = { \"gpu_enabled\" : { \"env\" : [ \"gpu_enabled\" , \"gpu\" ]}, }","title":"Settings"},{"location":"reference/dolphin/workflows/config_yml/","text":"add_dolphin_section ( cfg ) Add package and runtime metadata to a loaded config. Parameters: Name Type Description Default cfg dict Loaded configuration dict from load_yaml required Returns: Name Type Description cfg dict Configuration dict with added \"dolphin\" section Source code in dolphin/workflows/config_yml.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def add_dolphin_section ( cfg ): \"\"\"Add package and runtime metadata to a loaded config. Parameters ---------- cfg : dict Loaded configuration dict from `load_yaml` Returns ------- cfg : dict Configuration dict with added \"dolphin\" section \"\"\" from dolphin import __version__ from dolphin._show_versions import _get_sys_info dolphin_cfg = { \"version\" : __version__ , \"runtime\" : str ( datetime . datetime . now ()), \"sys_info\" : _get_sys_info (), # TODO: anything else relevant? } cfg [ \"runconfig\" ][ \"groups\" ][ \"processing\" ][ \"dolphin\" ] = dolphin_cfg return cfg get_workflow_yaml_path ( name = 's1_disp.yaml' , yaml_type = 'schemas' ) Get the path to a yaml schema or default file. Parameters: Name Type Description Default name str Name of the schema 's1_disp.yaml' yaml_type str , choices Which type of yaml file to get 'schemas' Returns: Name Type Description path str Path to the schema Source code in dolphin/workflows/config_yml.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_workflow_yaml_path ( name : str = \"s1_disp.yaml\" , yaml_type : str = \"schemas\" ): \"\"\"Get the path to a yaml schema or default file. Parameters ---------- name : str Name of the schema yaml_type : str, choices = [\"schemas\", \"defaults\"] Which type of yaml file to get Returns ------- path : str Path to the schema \"\"\" if yaml_type not in [ \"schemas\" , \"defaults\" ]: raise ValueError ( \"yaml_type must be one of ['schemas', 'defaults']\" ) outpath = Path ( __file__ ) . parent / yaml_type / name if outpath . suffix != \".yaml\" : outpath = outpath . with_suffix ( \".yaml\" ) return outpath load_workflow_yaml ( input_path , * , workflow_name = 's1_disp' ) Load and validate a yaml file for a workflow. Parameters: Name Type Description Default input_path Pathlike Path to the yaml file to load required workflow_name str Name of the workflow to load. Used to determine the path to the schema and defaults files. 's1_disp' Returns: Name Type Description data dict Dictionary containing the yaml data Source code in dolphin/workflows/config_yml.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def load_workflow_yaml ( input_path : Filename , * , workflow_name : str = \"s1_disp\" ): \"\"\"Load and validate a yaml file for a workflow. Parameters ---------- input_path : Pathlike Path to the yaml file to load workflow_name : str Name of the workflow to load. Used to determine the path to the schema and defaults files. Returns ------- data : dict Dictionary containing the yaml data \"\"\" parser = YAML ( typ = \"safe\" ) with open ( input_path , \"r\" ) as f : supplied = parser . load ( f ) defaults_path = get_workflow_yaml_path ( name = workflow_name , yaml_type = \"defaults\" ) with open ( defaults_path , \"r\" ) as f : defaults = parser . load ( f ) updated = _deep_update ( defaults = defaults , supplied = supplied ) # d = yamale.make_data([(updated, None)]) schema_path = get_workflow_yaml_path ( name = workflow_name , yaml_type = \"schemas\" ) schema = yamale . make_schema ( schema_path ) yamale . validate ( schema , [( updated , None )]) return updated save_yaml ( output_path , data ) Save a yaml file for a workflow. Used to record the default-filled version of a supplied yaml. Parameters: Name Type Description Default data dict Dictionary containing the yaml data required output_path Pathlike Path to the yaml file to save required Source code in dolphin/workflows/config_yml.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def save_yaml ( output_path : Filename , data : dict ): \"\"\"Save a yaml file for a workflow. Used to record the default-filled version of a supplied yaml. Parameters ---------- data : dict Dictionary containing the yaml data output_path : Pathlike Path to the yaml file to save \"\"\" y = YAML () with open ( output_path , \"w\" ) as f : y . dump ( data , f )","title":"config_yml"},{"location":"reference/dolphin/workflows/config_yml/#dolphin.workflows.config_yml.add_dolphin_section","text":"Add package and runtime metadata to a loaded config. Parameters: Name Type Description Default cfg dict Loaded configuration dict from load_yaml required Returns: Name Type Description cfg dict Configuration dict with added \"dolphin\" section Source code in dolphin/workflows/config_yml.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def add_dolphin_section ( cfg ): \"\"\"Add package and runtime metadata to a loaded config. Parameters ---------- cfg : dict Loaded configuration dict from `load_yaml` Returns ------- cfg : dict Configuration dict with added \"dolphin\" section \"\"\" from dolphin import __version__ from dolphin._show_versions import _get_sys_info dolphin_cfg = { \"version\" : __version__ , \"runtime\" : str ( datetime . datetime . now ()), \"sys_info\" : _get_sys_info (), # TODO: anything else relevant? } cfg [ \"runconfig\" ][ \"groups\" ][ \"processing\" ][ \"dolphin\" ] = dolphin_cfg return cfg","title":"add_dolphin_section()"},{"location":"reference/dolphin/workflows/config_yml/#dolphin.workflows.config_yml.get_workflow_yaml_path","text":"Get the path to a yaml schema or default file. Parameters: Name Type Description Default name str Name of the schema 's1_disp.yaml' yaml_type str , choices Which type of yaml file to get 'schemas' Returns: Name Type Description path str Path to the schema Source code in dolphin/workflows/config_yml.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_workflow_yaml_path ( name : str = \"s1_disp.yaml\" , yaml_type : str = \"schemas\" ): \"\"\"Get the path to a yaml schema or default file. Parameters ---------- name : str Name of the schema yaml_type : str, choices = [\"schemas\", \"defaults\"] Which type of yaml file to get Returns ------- path : str Path to the schema \"\"\" if yaml_type not in [ \"schemas\" , \"defaults\" ]: raise ValueError ( \"yaml_type must be one of ['schemas', 'defaults']\" ) outpath = Path ( __file__ ) . parent / yaml_type / name if outpath . suffix != \".yaml\" : outpath = outpath . with_suffix ( \".yaml\" ) return outpath","title":"get_workflow_yaml_path()"},{"location":"reference/dolphin/workflows/config_yml/#dolphin.workflows.config_yml.load_workflow_yaml","text":"Load and validate a yaml file for a workflow. Parameters: Name Type Description Default input_path Pathlike Path to the yaml file to load required workflow_name str Name of the workflow to load. Used to determine the path to the schema and defaults files. 's1_disp' Returns: Name Type Description data dict Dictionary containing the yaml data Source code in dolphin/workflows/config_yml.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def load_workflow_yaml ( input_path : Filename , * , workflow_name : str = \"s1_disp\" ): \"\"\"Load and validate a yaml file for a workflow. Parameters ---------- input_path : Pathlike Path to the yaml file to load workflow_name : str Name of the workflow to load. Used to determine the path to the schema and defaults files. Returns ------- data : dict Dictionary containing the yaml data \"\"\" parser = YAML ( typ = \"safe\" ) with open ( input_path , \"r\" ) as f : supplied = parser . load ( f ) defaults_path = get_workflow_yaml_path ( name = workflow_name , yaml_type = \"defaults\" ) with open ( defaults_path , \"r\" ) as f : defaults = parser . load ( f ) updated = _deep_update ( defaults = defaults , supplied = supplied ) # d = yamale.make_data([(updated, None)]) schema_path = get_workflow_yaml_path ( name = workflow_name , yaml_type = \"schemas\" ) schema = yamale . make_schema ( schema_path ) yamale . validate ( schema , [( updated , None )]) return updated","title":"load_workflow_yaml()"},{"location":"reference/dolphin/workflows/config_yml/#dolphin.workflows.config_yml.save_yaml","text":"Save a yaml file for a workflow. Used to record the default-filled version of a supplied yaml. Parameters: Name Type Description Default data dict Dictionary containing the yaml data required output_path Pathlike Path to the yaml file to save required Source code in dolphin/workflows/config_yml.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def save_yaml ( output_path : Filename , data : dict ): \"\"\"Save a yaml file for a workflow. Used to record the default-filled version of a supplied yaml. Parameters ---------- data : dict Dictionary containing the yaml data output_path : Pathlike Path to the yaml file to save \"\"\" y = YAML () with open ( output_path , \"w\" ) as f : y . dump ( data , f )","title":"save_yaml()"},{"location":"reference/dolphin/workflows/s1_disp_stack/","text":"run ( full_cfg , debug = False ) Run the displacement workflow on a stack of SLCs. Parameters: Name Type Description Default full_cfg dict Loaded configuration from YAML workflow file. required debug bool , optional Enable debug logging, by default False. False Source code in dolphin/workflows/s1_disp_stack.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @log_runtime def run ( full_cfg : dict , debug : bool = False ): \"\"\"Run the displacement workflow on a stack of SLCs. Parameters ---------- full_cfg : dict Loaded configuration from YAML workflow file. debug : bool, optional Enable debug logging, by default False. \"\"\" logger = get_log ( debug = debug ) cfg = full_cfg [ \"processing\" ] output_dir = Path ( full_cfg [ \"product_path_group\" ][ \"product_path\" ]) . absolute () output_dir . mkdir ( parents = True , exist_ok = True ) scratch_dir = Path ( full_cfg [ \"product_path_group\" ][ \"scratch_path\" ]) . absolute () scratch_dir . mkdir ( parents = True , exist_ok = True ) # sas_output_file = full_cfg[\"product_path_group\"][\"sas_output_file\"] # gpu_enabled = full_cfg[\"worker\"][\"gpu_enabled\"] # n_workers = full_cfg[\"worker\"][\"n_workers\"] input_file_list = full_cfg [ \"input_file_group\" ][ \"cslc_file_list\" ] input_file_path = full_cfg [ \"input_file_group\" ][ \"cslc_file_path\" ] if not input_file_list : if not input_file_path : raise ValueError ( \"Must specify either cslc_file_list or cslc_file_path\" ) input_file_path = Path ( input_file_path ) . absolute () ext = full_cfg [ \"input_file_group\" ][ \"cslc_file_ext\" ] # TODO : somehow accommodate inputs other than ENVI input_file_list = sorted ( glob ( fspath ( input_file_path / f \"* { ext } \" ))) # ############################################# # 0. Make a VRT pointing to the input SLC files # ############################################# # slc_vrt_file = scratch_dir / \"slc_stack.vrt\" # vrt_stack = vrt.VRTStack(input_file_list, outfile=slc_vrt_file) # vrt_stack.write() # ####################### # 1. Amplitude dispersion # ####################### ps_path = scratch_dir / cfg [ \"ps\" ][ \"directory\" ] ps_path . mkdir ( parents = True , exist_ok = True ) amp_disp_file = ps_path / full_cfg [ \"dynamic_ancillary_file_group\" ][ \"amp_disp_file\" ] # amp_mean_file = ps_path / full_cfg[\"dynamic_ancillary_file_group\"][\"amp_mean_file\"] if amp_disp_file . exists (): logger . info ( f \"Skipping existing amplitude dispersion file { amp_disp_file } \" ) else : logger . info ( f \"Making amplitude dispersion file { amp_disp_file } \" ) # Create the amplitude dispersion using PS module # ############### # 2. PS selection # ############### ps_output = ps_path / cfg [ \"ps_file\" ] # threshold = cfg[\"ps\"][\"amp_dispersion_threshold\"] if ps_output . exists (): logger . info ( f \"Skipping making existing PS file { ps_output } \" ) else : logger . info ( f \"Creating persistent scatterer file { ps_output } \" ) # ps.create_ps(...) # ############################### # nmap: find SHP neighborhoods # ############################### # # (This will be optional, possibly entirely skipped if it's too slow) # nmap_path = scratch_dir / cfg[\"nmap\"][\"directory\"] # nmap_path.mkdir(parents=True, exist_ok=True) # weight_file = nmap_path / cfg[\"weight_file\"] # # threshold = cfg[\"ps\"][\"amp_dispersion_threshold\"] # if not cfg[\"nmap\"][\"run_nmap\"] or weight_file.exists(): # logger.info(f\"Skipping making existing NMAP file {weight_file}\") # else: # # Make the dummy nmap/count files # logger.info(f\"Creating NMAP file {weight_file}\") # # phase_link.run_nmap( ... ) # ######################### # 3. phase linking/EVD step # ######################### pl_path = scratch_dir / cfg [ \"phase_linking\" ][ \"directory\" ] # For some reason fringe skips this one if the directory exists... # pl_path.mkdir(parents=True, exist_ok=True) # compressed_slc_file = pl_path / cfg[\"phase_linking\"][\"compressed_slc_file\"] # if compressed_slc_file.exists(): # logger.info(f\"Skipping making existing EVD file {compressed_slc_file}\") existing_files = list ( pl_path . glob ( \"*.slc.tif\" )) # TODO: get ext from config if len ( existing_files ) > 0 : logger . info ( f \"Skipping EVD step, { len ( existing_files ) } files already exist\" ) else : logger . info ( f \"Running sequential EMI step in { pl_path } \" ) # pl_path = sequential.run_evd_sequential( ... ) # ################################################### # 4. Form interferograms from estimated wrapped phase # ################################################### ps_ds_path = scratch_dir / cfg [ \"combine_ps_ds\" ][ \"directory\" ] ps_ds_path . mkdir ( parents = True , exist_ok = True ) # # Combine the temp coh files made in last step: # temp_coh_file = pl_path / \"tcorr_average.tif\" existing_ifgs = list ( ps_ds_path . glob ( \"*.int*\" )) if len ( existing_ifgs ) > 0 : logger . info ( f \"Skipping combine_ps_ds step, { len ( existing_ifgs ) } exists\" ) else : logger . info ( f \"Running combine ps/ds step into { ps_ds_path } \" ) # The python MLE function handles the temp coh, and the PS phase insertion # interferograms.form_ifgs( ... ) # ################################### # 5. Stitch and Unwrap interferograms # ################################### # TODO: will this be a separate workflow? # Or will we loop through all bursts, then stitch, then unwrap all here? if not cfg [ \"unwrap\" ][ \"run_unwrap\" ]: logger . info ( \"Skipping unwrap step\" ) return unwrap_path = scratch_dir / cfg [ \"unwrap\" ][ \"directory\" ] unwrap_path . mkdir ( parents = True , exist_ok = True )","title":"s1_disp_stack"},{"location":"reference/dolphin/workflows/s1_disp_stack/#dolphin.workflows.s1_disp_stack.run","text":"Run the displacement workflow on a stack of SLCs. Parameters: Name Type Description Default full_cfg dict Loaded configuration from YAML workflow file. required debug bool , optional Enable debug logging, by default False. False Source code in dolphin/workflows/s1_disp_stack.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @log_runtime def run ( full_cfg : dict , debug : bool = False ): \"\"\"Run the displacement workflow on a stack of SLCs. Parameters ---------- full_cfg : dict Loaded configuration from YAML workflow file. debug : bool, optional Enable debug logging, by default False. \"\"\" logger = get_log ( debug = debug ) cfg = full_cfg [ \"processing\" ] output_dir = Path ( full_cfg [ \"product_path_group\" ][ \"product_path\" ]) . absolute () output_dir . mkdir ( parents = True , exist_ok = True ) scratch_dir = Path ( full_cfg [ \"product_path_group\" ][ \"scratch_path\" ]) . absolute () scratch_dir . mkdir ( parents = True , exist_ok = True ) # sas_output_file = full_cfg[\"product_path_group\"][\"sas_output_file\"] # gpu_enabled = full_cfg[\"worker\"][\"gpu_enabled\"] # n_workers = full_cfg[\"worker\"][\"n_workers\"] input_file_list = full_cfg [ \"input_file_group\" ][ \"cslc_file_list\" ] input_file_path = full_cfg [ \"input_file_group\" ][ \"cslc_file_path\" ] if not input_file_list : if not input_file_path : raise ValueError ( \"Must specify either cslc_file_list or cslc_file_path\" ) input_file_path = Path ( input_file_path ) . absolute () ext = full_cfg [ \"input_file_group\" ][ \"cslc_file_ext\" ] # TODO : somehow accommodate inputs other than ENVI input_file_list = sorted ( glob ( fspath ( input_file_path / f \"* { ext } \" ))) # ############################################# # 0. Make a VRT pointing to the input SLC files # ############################################# # slc_vrt_file = scratch_dir / \"slc_stack.vrt\" # vrt_stack = vrt.VRTStack(input_file_list, outfile=slc_vrt_file) # vrt_stack.write() # ####################### # 1. Amplitude dispersion # ####################### ps_path = scratch_dir / cfg [ \"ps\" ][ \"directory\" ] ps_path . mkdir ( parents = True , exist_ok = True ) amp_disp_file = ps_path / full_cfg [ \"dynamic_ancillary_file_group\" ][ \"amp_disp_file\" ] # amp_mean_file = ps_path / full_cfg[\"dynamic_ancillary_file_group\"][\"amp_mean_file\"] if amp_disp_file . exists (): logger . info ( f \"Skipping existing amplitude dispersion file { amp_disp_file } \" ) else : logger . info ( f \"Making amplitude dispersion file { amp_disp_file } \" ) # Create the amplitude dispersion using PS module # ############### # 2. PS selection # ############### ps_output = ps_path / cfg [ \"ps_file\" ] # threshold = cfg[\"ps\"][\"amp_dispersion_threshold\"] if ps_output . exists (): logger . info ( f \"Skipping making existing PS file { ps_output } \" ) else : logger . info ( f \"Creating persistent scatterer file { ps_output } \" ) # ps.create_ps(...) # ############################### # nmap: find SHP neighborhoods # ############################### # # (This will be optional, possibly entirely skipped if it's too slow) # nmap_path = scratch_dir / cfg[\"nmap\"][\"directory\"] # nmap_path.mkdir(parents=True, exist_ok=True) # weight_file = nmap_path / cfg[\"weight_file\"] # # threshold = cfg[\"ps\"][\"amp_dispersion_threshold\"] # if not cfg[\"nmap\"][\"run_nmap\"] or weight_file.exists(): # logger.info(f\"Skipping making existing NMAP file {weight_file}\") # else: # # Make the dummy nmap/count files # logger.info(f\"Creating NMAP file {weight_file}\") # # phase_link.run_nmap( ... ) # ######################### # 3. phase linking/EVD step # ######################### pl_path = scratch_dir / cfg [ \"phase_linking\" ][ \"directory\" ] # For some reason fringe skips this one if the directory exists... # pl_path.mkdir(parents=True, exist_ok=True) # compressed_slc_file = pl_path / cfg[\"phase_linking\"][\"compressed_slc_file\"] # if compressed_slc_file.exists(): # logger.info(f\"Skipping making existing EVD file {compressed_slc_file}\") existing_files = list ( pl_path . glob ( \"*.slc.tif\" )) # TODO: get ext from config if len ( existing_files ) > 0 : logger . info ( f \"Skipping EVD step, { len ( existing_files ) } files already exist\" ) else : logger . info ( f \"Running sequential EMI step in { pl_path } \" ) # pl_path = sequential.run_evd_sequential( ... ) # ################################################### # 4. Form interferograms from estimated wrapped phase # ################################################### ps_ds_path = scratch_dir / cfg [ \"combine_ps_ds\" ][ \"directory\" ] ps_ds_path . mkdir ( parents = True , exist_ok = True ) # # Combine the temp coh files made in last step: # temp_coh_file = pl_path / \"tcorr_average.tif\" existing_ifgs = list ( ps_ds_path . glob ( \"*.int*\" )) if len ( existing_ifgs ) > 0 : logger . info ( f \"Skipping combine_ps_ds step, { len ( existing_ifgs ) } exists\" ) else : logger . info ( f \"Running combine ps/ds step into { ps_ds_path } \" ) # The python MLE function handles the temp coh, and the PS phase insertion # interferograms.form_ifgs( ... ) # ################################### # 5. Stitch and Unwrap interferograms # ################################### # TODO: will this be a separate workflow? # Or will we loop through all bursts, then stitch, then unwrap all here? if not cfg [ \"unwrap\" ][ \"run_unwrap\" ]: logger . info ( \"Skipping unwrap step\" ) return unwrap_path = scratch_dir / cfg [ \"unwrap\" ][ \"directory\" ] unwrap_path . mkdir ( parents = True , exist_ok = True )","title":"run()"}]}