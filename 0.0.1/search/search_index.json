{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dolphin Documentation Table Of Contents Getting started Tutorials How-To Guides Code Reference Background theory","title":"Dolphin Documentation"},{"location":"#dolphin-documentation","text":"","title":"Dolphin Documentation"},{"location":"#table-of-contents","text":"Getting started Tutorials How-To Guides Code Reference Background theory","title":"Table Of Contents"},{"location":"background-theory/","text":"","title":"Background theory"},{"location":"getting-started/","text":"Dolphin has a main command line entry point to run the algorithms and tools in workflows. The main entry point is named dolphin , which has two subcommands: dolphin config : create a workflow configuration file. dolphin run : run the workflow using this file. Example usage: $ dolphin config --slc-directory /path/to/slc --ext \".tif\" This will create a YAML file (by default dolphin_config.yaml in the current directory). You can also directly use a list of SLC files as input, e.g.: $ dolphin config --slc-files /path/to/slc1.tif /path/to/slc2.tif Install The following will install dolphin into a conda environment. Download source code: git clone https://github.com/opera-adt/dolphin.git && cd dolphin Install dependencies: # assuming that mamba is installed: https://mamba.readthedocs.io/en/latest/ # if not, start with: # conda install mamba -n base -c conda-forge mamba install -c conda-forge --file requirements.txt Install dolphin via pip: # -e installs in development mode python -m pip install -e . For development: # run \"pip install -e\" to install with extra development requirements python -m pip install -e .[docs] # Get pre-commit hooks so that linting/formatting is done automatically pre-commit install # After making changes, check the tests: pytest Creating Documentation We use MKDocs to generate the documentation. The reference documentation is generated from the code docstrings using mkdocstrings . When adding new documentation, you can build and serve the documentation locally using: mkdocs serve then open http://localhost:8000 in your browser. Creating new files or updating existing files will automatically trigger a rebuild of the documentation while mkdocs serve is running. The online documentation is hosted using Github Pages and versioned using Mike . Manually deploying new versions (copied from https://github.com/squidfunk/mkdocs-material-example-versioning) Make a change to docs/index.md, and publish the first version: mike deploy --push --update-aliases 0.1 latest Set the default version to latest mike set-default --push latest","title":"Getting started"},{"location":"getting-started/#install","text":"The following will install dolphin into a conda environment. Download source code: git clone https://github.com/opera-adt/dolphin.git && cd dolphin Install dependencies: # assuming that mamba is installed: https://mamba.readthedocs.io/en/latest/ # if not, start with: # conda install mamba -n base -c conda-forge mamba install -c conda-forge --file requirements.txt Install dolphin via pip: # -e installs in development mode python -m pip install -e . For development: # run \"pip install -e\" to install with extra development requirements python -m pip install -e .[docs] # Get pre-commit hooks so that linting/formatting is done automatically pre-commit install # After making changes, check the tests: pytest","title":"Install"},{"location":"getting-started/#creating-documentation","text":"We use MKDocs to generate the documentation. The reference documentation is generated from the code docstrings using mkdocstrings . When adding new documentation, you can build and serve the documentation locally using: mkdocs serve then open http://localhost:8000 in your browser. Creating new files or updating existing files will automatically trigger a rebuild of the documentation while mkdocs serve is running. The online documentation is hosted using Github Pages and versioned using Mike .","title":"Creating Documentation"},{"location":"getting-started/#manually-deploying-new-versions","text":"(copied from https://github.com/squidfunk/mkdocs-material-example-versioning) Make a change to docs/index.md, and publish the first version: mike deploy --push --update-aliases 0.1 latest Set the default version to latest mike set-default --push latest","title":"Manually deploying new versions"},{"location":"how-to-guides/","text":"","title":"How to guides"},{"location":"tutorials/","text":"This part of the project documentation will contain step-by-step instructions for learning about generating displacement using Dolphin.","title":"Tutorials"},{"location":"reference/summary/","text":"dolphin _log _show_versions _version cli utils workflows _config_cli _enums _run_cli config s1_disp_stack","title":"Summary"},{"location":"reference/dolphin/","text":"","title":"dolphin"},{"location":"reference/dolphin/_log/","text":"Exports a get_log function which sets up easy logging. Uses the standard python logging utilities, just provides nice formatting out of the box across multiple files. Usage: from ._log import get_log logger = get_log() logger.info(\"Something happened\") logger.warning(\"Something concerning happened\") logger.error(\"Something bad happened\") logger.critical(\"Something just awful happened\") logger.debug(\"Extra printing we often don't need to see.\") # Custom output for this module: logger.success(\"Something great happened: highlight this success\") format_log ( logger , debug = False ) Make the logging output pretty and colored with times. Parameters: Name Type Description Default logger logging . Logger The logger to format required debug bool (Default value If true, sets logging level to DEBUG False Returns: Type Description logging . Logger Source code in dolphin/_log.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def format_log ( logger , debug = False ): \"\"\"Make the logging output pretty and colored with times. Parameters ---------- logger : logging.Logger The logger to format debug : bool (Default value = False) If true, sets logging level to DEBUG Returns ------- logging.Logger \"\"\" log_level = logging . DEBUG if debug else logging . INFO format_ = \"[ %(asctime)s ] [ %(levelname)s %(filename)s ] %(message)s \" formatter = Formatter ( format_ , datefmt = \"%m/ %d %H:%M:%S\" ) handler = logging . StreamHandler () handler . setFormatter ( formatter ) if not logger . handlers : logger . addHandler ( handler ) logger . setLevel ( log_level ) if debug : logger . setLevel ( debug ) return logger get_log ( debug = False , name = 'dolphin.log' ) Create a nice log format for use across multiple files. Default logging level is INFO Parameters: Name Type Description Default name Optional [ str ] The name the logger will use when printing statements (Default value = \"dolphin.log\") 'dolphin.log' debug Optional [ bool ] If true, sets logging level to DEBUG (Default value = False) False Returns: Type Description logging . Logger Source code in dolphin/_log.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def get_log ( debug = False , name = \"dolphin.log\" ): \"\"\"Create a nice log format for use across multiple files. Default logging level is INFO Parameters ---------- name : Optional[str] The name the logger will use when printing statements (Default value = \"dolphin.log\") debug : Optional[bool] If true, sets logging level to DEBUG (Default value = False) Returns ------- logging.Logger \"\"\" logger = logging . getLogger ( name ) return format_log ( logger , debug = debug ) log_runtime ( f ) Decorate a function to time how long it takes to run. Usage @log_runtime def test_func(): return 2 + 4 Source code in dolphin/_log.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def log_runtime ( f ): \"\"\"Decorate a function to time how long it takes to run. Usage ----- @log_runtime def test_func(): return 2 + 4 \"\"\" logger = get_log () def wrapper ( * args , ** kwargs ): t1 = time . time () result = f ( * args , ** kwargs ) t2 = time . time () elapsed_time = t2 - t1 time_string = \"Total elapsed time for {} : {} minutes ( {} seconds)\" . format ( f . __name__ , \" {0:.2f} \" . format ( elapsed_time / 60.0 ), \" {0:.2f} \" . format ( elapsed_time ), ) logger . info ( time_string ) return result return wrapper","title":"_log"},{"location":"reference/dolphin/_log/#dolphin._log.format_log","text":"Make the logging output pretty and colored with times. Parameters: Name Type Description Default logger logging . Logger The logger to format required debug bool (Default value If true, sets logging level to DEBUG False Returns: Type Description logging . Logger Source code in dolphin/_log.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def format_log ( logger , debug = False ): \"\"\"Make the logging output pretty and colored with times. Parameters ---------- logger : logging.Logger The logger to format debug : bool (Default value = False) If true, sets logging level to DEBUG Returns ------- logging.Logger \"\"\" log_level = logging . DEBUG if debug else logging . INFO format_ = \"[ %(asctime)s ] [ %(levelname)s %(filename)s ] %(message)s \" formatter = Formatter ( format_ , datefmt = \"%m/ %d %H:%M:%S\" ) handler = logging . StreamHandler () handler . setFormatter ( formatter ) if not logger . handlers : logger . addHandler ( handler ) logger . setLevel ( log_level ) if debug : logger . setLevel ( debug ) return logger","title":"format_log()"},{"location":"reference/dolphin/_log/#dolphin._log.get_log","text":"Create a nice log format for use across multiple files. Default logging level is INFO Parameters: Name Type Description Default name Optional [ str ] The name the logger will use when printing statements (Default value = \"dolphin.log\") 'dolphin.log' debug Optional [ bool ] If true, sets logging level to DEBUG (Default value = False) False Returns: Type Description logging . Logger Source code in dolphin/_log.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def get_log ( debug = False , name = \"dolphin.log\" ): \"\"\"Create a nice log format for use across multiple files. Default logging level is INFO Parameters ---------- name : Optional[str] The name the logger will use when printing statements (Default value = \"dolphin.log\") debug : Optional[bool] If true, sets logging level to DEBUG (Default value = False) Returns ------- logging.Logger \"\"\" logger = logging . getLogger ( name ) return format_log ( logger , debug = debug )","title":"get_log()"},{"location":"reference/dolphin/_log/#dolphin._log.log_runtime","text":"Decorate a function to time how long it takes to run.","title":"log_runtime()"},{"location":"reference/dolphin/_log/#dolphin._log.log_runtime--usage","text":"@log_runtime def test_func(): return 2 + 4 Source code in dolphin/_log.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def log_runtime ( f ): \"\"\"Decorate a function to time how long it takes to run. Usage ----- @log_runtime def test_func(): return 2 + 4 \"\"\" logger = get_log () def wrapper ( * args , ** kwargs ): t1 = time . time () result = f ( * args , ** kwargs ) t2 = time . time () elapsed_time = t2 - t1 time_string = \"Total elapsed time for {} : {} minutes ( {} seconds)\" . format ( f . __name__ , \" {0:.2f} \" . format ( elapsed_time / 60.0 ), \" {0:.2f} \" . format ( elapsed_time ), ) logger . info ( time_string ) return result return wrapper","title":"Usage"},{"location":"reference/dolphin/_show_versions/","text":"Utility methods to print system info for debugging. Adapted from rasterio.show_versions , which was adapted from sklearn.utils._show_versions which was adapted from pandas.show_versions show_versions () Print useful debugging information. Examples: python -c \"import dolphin; dolphin.show_versions()\" Source code in dolphin/_show_versions.py 92 93 94 95 96 97 98 99 100 101 102 103 104 def show_versions (): \"\"\"Print useful debugging information. Examples -------- > python -c \"import dolphin; dolphin.show_versions()\" \"\"\" print ( \"dolphin info:\" ) _print_info_dict ( _get_opera_info ()) print ( \" \\n System:\" ) _print_info_dict ( _get_sys_info ()) print ( \" \\n Python deps:\" ) _print_info_dict ( _get_deps_info ())","title":"_show_versions"},{"location":"reference/dolphin/_show_versions/#dolphin._show_versions.show_versions","text":"Print useful debugging information. Examples: python -c \"import dolphin; dolphin.show_versions()\" Source code in dolphin/_show_versions.py 92 93 94 95 96 97 98 99 100 101 102 103 104 def show_versions (): \"\"\"Print useful debugging information. Examples -------- > python -c \"import dolphin; dolphin.show_versions()\" \"\"\" print ( \"dolphin info:\" ) _print_info_dict ( _get_opera_info ()) print ( \" \\n System:\" ) _print_info_dict ( _get_sys_info ()) print ( \" \\n Python deps:\" ) _print_info_dict ( _get_deps_info ())","title":"show_versions()"},{"location":"reference/dolphin/_version/","text":"","title":"_version"},{"location":"reference/dolphin/cli/","text":"main ( args = None ) Top-level command line interface to the workflows. Source code in dolphin/cli.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def main ( args = None ): \"\"\"Top-level command line interface to the workflows.\"\"\" import dolphin.workflows._config_cli import dolphin.workflows._run_cli parser = argparse . ArgumentParser ( prog = __package__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) subparser = parser . add_subparsers ( title = \"subcommands\" ) # Adds the subcommand to the top-level parser _ = dolphin . workflows . _run_cli . get_parser ( subparser , \"run\" ) _ = dolphin . workflows . _config_cli . get_parser ( subparser , \"config\" ) parsed_args = parser . parse_args ( args = args ) arg_dict = vars ( parsed_args ) run_func = arg_dict . pop ( \"run_func\" ) run_func ( ** arg_dict )","title":"cli"},{"location":"reference/dolphin/cli/#dolphin.cli.main","text":"Top-level command line interface to the workflows. Source code in dolphin/cli.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def main ( args = None ): \"\"\"Top-level command line interface to the workflows.\"\"\" import dolphin.workflows._config_cli import dolphin.workflows._run_cli parser = argparse . ArgumentParser ( prog = __package__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) subparser = parser . add_subparsers ( title = \"subcommands\" ) # Adds the subcommand to the top-level parser _ = dolphin . workflows . _run_cli . get_parser ( subparser , \"run\" ) _ = dolphin . workflows . _config_cli . get_parser ( subparser , \"config\" ) parsed_args = parser . parse_args ( args = args ) arg_dict = vars ( parsed_args ) run_func = arg_dict . pop ( \"run_func\" ) run_func ( ** arg_dict )","title":"main()"},{"location":"reference/dolphin/utils/","text":"gdal_to_numpy_type ( gdal_type ) Convert gdal type to numpy type. Source code in dolphin/utils.py 30 31 32 33 34 def gdal_to_numpy_type ( gdal_type ): \"\"\"Convert gdal type to numpy type.\"\"\" if isinstance ( gdal_type , str ): gdal_type = gdal . GetDataTypeByName ( gdal_type ) return gdal_array . GDALTypeCodeToNumericTypeCode ( gdal_type ) get_dates ( filename , fmt = '%Y%m %d ' ) Search for dates in the stem of filename matching fmt . Excludes dates that are not in the stem of filename (in the directories). Parameters: Name Type Description Default filename str or PathLike Filename to search for dates. required fmt str , optional Format of date to search for. Default is \"%Y%m%d\". '%Y%m%d' Returns: Type Description list[str] or None List of dates found in the stem of filename matching fmt . Returns None if nothing is found. Examples: >>> get_dates ( \"/path/to/20191231.slc.tif\" ) ['20191231'] >>> get_dates ( \"S1A_IW_SLC__1SDV_20191231T000000_20191231T000000_032123_03B8F1_1C1D.nc\" ) ['20191231', '20191231'] >>> get_dates ( \"/not/a/date_named_file.tif\" ) [] Source code in dolphin/utils.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def get_dates ( filename : Filename , fmt = \"%Y%m %d \" ) -> List [ Union [ None , str ]]: \"\"\"Search for dates in the stem of `filename` matching `fmt`. Excludes dates that are not in the stem of `filename` (in the directories). Parameters ---------- filename : str or PathLike Filename to search for dates. fmt : str, optional Format of date to search for. Default is \"%Y%m%d\". Returns ------- list[str] or None List of dates found in the stem of `filename` matching `fmt`. Returns None if nothing is found. Examples -------- >>> get_dates(\"/path/to/20191231.slc.tif\") ['20191231'] >>> get_dates(\"S1A_IW_SLC__1SDV_20191231T000000_20191231T000000_032123_03B8F1_1C1D.nc\") ['20191231', '20191231'] >>> get_dates(\"/not/a/date_named_file.tif\") [] \"\"\" # noqa: E501 pat = _date_format_to_regex ( fmt ) date_list = re . findall ( pat , Path ( filename ) . stem ) if not date_list : msg = f \" { filename } does not contain date as YYYYMMDD\" logger . warning ( msg ) return [] return date_list numpy_to_gdal_type ( np_dtype ) Convert numpy dtype to gdal type. Source code in dolphin/utils.py 17 18 19 20 21 22 23 24 25 26 27 def numpy_to_gdal_type ( np_dtype ): \"\"\"Convert numpy dtype to gdal type.\"\"\" # Wrap in np.dtype in case string is passed if isinstance ( np_dtype , str ): np_dtype = np . dtype ( np_dtype . lower ()) elif isinstance ( np_dtype , type ): np_dtype = np . dtype ( np_dtype ) if np . issubdtype ( bool , np_dtype ): return gdalconst . GDT_Byte return gdal_array . NumericTypeCodeToGDALTypeCode ( np_dtype ) parse_slc_strings ( slc_str , fmt = '%Y%m %d ' ) Parse a string, or list of strings, matching fmt into datetime.date. Parameters: Name Type Description Default slc_str str or list of str String or list of strings to parse. required fmt str , optional Format of string to parse. Default is \"%Y%m%d\". '%Y%m%d' Returns: Type Description datetime.date, or list of datetime.date Source code in dolphin/utils.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def parse_slc_strings ( slc_str : Union [ Filename , List [ Filename ]], fmt = \"%Y%m %d \" ): \"\"\"Parse a string, or list of strings, matching `fmt` into datetime.date. Parameters ---------- slc_str : str or list of str String or list of strings to parse. fmt : str, optional Format of string to parse. Default is \"%Y%m%d\". Returns ------- datetime.date, or list of datetime.date \"\"\" def _parse ( datestr , fmt = \"%Y%m %d \" ) -> datetime . date : return datetime . datetime . strptime ( datestr , fmt ) . date () # The re.search will find YYYYMMDD anywhere in string if isinstance ( slc_str , str ) or hasattr ( slc_str , \"__fspath__\" ): d_list = get_dates ( slc_str , fmt = fmt ) if not d_list : raise ValueError ( f \"Could not find date of format { fmt } in { slc_str } \" ) return _parse ( d_list [ 0 ], fmt = fmt ) else : # If it's an iterable of strings, run on each one return [ parse_slc_strings ( s , fmt = fmt ) for s in slc_str if s ]","title":"utils"},{"location":"reference/dolphin/utils/#dolphin.utils.gdal_to_numpy_type","text":"Convert gdal type to numpy type. Source code in dolphin/utils.py 30 31 32 33 34 def gdal_to_numpy_type ( gdal_type ): \"\"\"Convert gdal type to numpy type.\"\"\" if isinstance ( gdal_type , str ): gdal_type = gdal . GetDataTypeByName ( gdal_type ) return gdal_array . GDALTypeCodeToNumericTypeCode ( gdal_type )","title":"gdal_to_numpy_type()"},{"location":"reference/dolphin/utils/#dolphin.utils.get_dates","text":"Search for dates in the stem of filename matching fmt . Excludes dates that are not in the stem of filename (in the directories). Parameters: Name Type Description Default filename str or PathLike Filename to search for dates. required fmt str , optional Format of date to search for. Default is \"%Y%m%d\". '%Y%m%d' Returns: Type Description list[str] or None List of dates found in the stem of filename matching fmt . Returns None if nothing is found. Examples: >>> get_dates ( \"/path/to/20191231.slc.tif\" ) ['20191231'] >>> get_dates ( \"S1A_IW_SLC__1SDV_20191231T000000_20191231T000000_032123_03B8F1_1C1D.nc\" ) ['20191231', '20191231'] >>> get_dates ( \"/not/a/date_named_file.tif\" ) [] Source code in dolphin/utils.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def get_dates ( filename : Filename , fmt = \"%Y%m %d \" ) -> List [ Union [ None , str ]]: \"\"\"Search for dates in the stem of `filename` matching `fmt`. Excludes dates that are not in the stem of `filename` (in the directories). Parameters ---------- filename : str or PathLike Filename to search for dates. fmt : str, optional Format of date to search for. Default is \"%Y%m%d\". Returns ------- list[str] or None List of dates found in the stem of `filename` matching `fmt`. Returns None if nothing is found. Examples -------- >>> get_dates(\"/path/to/20191231.slc.tif\") ['20191231'] >>> get_dates(\"S1A_IW_SLC__1SDV_20191231T000000_20191231T000000_032123_03B8F1_1C1D.nc\") ['20191231', '20191231'] >>> get_dates(\"/not/a/date_named_file.tif\") [] \"\"\" # noqa: E501 pat = _date_format_to_regex ( fmt ) date_list = re . findall ( pat , Path ( filename ) . stem ) if not date_list : msg = f \" { filename } does not contain date as YYYYMMDD\" logger . warning ( msg ) return [] return date_list","title":"get_dates()"},{"location":"reference/dolphin/utils/#dolphin.utils.numpy_to_gdal_type","text":"Convert numpy dtype to gdal type. Source code in dolphin/utils.py 17 18 19 20 21 22 23 24 25 26 27 def numpy_to_gdal_type ( np_dtype ): \"\"\"Convert numpy dtype to gdal type.\"\"\" # Wrap in np.dtype in case string is passed if isinstance ( np_dtype , str ): np_dtype = np . dtype ( np_dtype . lower ()) elif isinstance ( np_dtype , type ): np_dtype = np . dtype ( np_dtype ) if np . issubdtype ( bool , np_dtype ): return gdalconst . GDT_Byte return gdal_array . NumericTypeCodeToGDALTypeCode ( np_dtype )","title":"numpy_to_gdal_type()"},{"location":"reference/dolphin/utils/#dolphin.utils.parse_slc_strings","text":"Parse a string, or list of strings, matching fmt into datetime.date. Parameters: Name Type Description Default slc_str str or list of str String or list of strings to parse. required fmt str , optional Format of string to parse. Default is \"%Y%m%d\". '%Y%m%d' Returns: Type Description datetime.date, or list of datetime.date Source code in dolphin/utils.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def parse_slc_strings ( slc_str : Union [ Filename , List [ Filename ]], fmt = \"%Y%m %d \" ): \"\"\"Parse a string, or list of strings, matching `fmt` into datetime.date. Parameters ---------- slc_str : str or list of str String or list of strings to parse. fmt : str, optional Format of string to parse. Default is \"%Y%m%d\". Returns ------- datetime.date, or list of datetime.date \"\"\" def _parse ( datestr , fmt = \"%Y%m %d \" ) -> datetime . date : return datetime . datetime . strptime ( datestr , fmt ) . date () # The re.search will find YYYYMMDD anywhere in string if isinstance ( slc_str , str ) or hasattr ( slc_str , \"__fspath__\" ): d_list = get_dates ( slc_str , fmt = fmt ) if not d_list : raise ValueError ( f \"Could not find date of format { fmt } in { slc_str } \" ) return _parse ( d_list [ 0 ], fmt = fmt ) else : # If it's an iterable of strings, run on each one return [ parse_slc_strings ( s , fmt = fmt ) for s in slc_str if s ]","title":"parse_slc_strings()"},{"location":"reference/dolphin/workflows/","text":"Tools for creating workflows and running displacement workflows.","title":"workflows"},{"location":"reference/dolphin/workflows/_config_cli/","text":"create_config ( * , outfile , slc_directory = None , ext = '.nc' , slc_files = None , mask_files = None , name = WorkflowName . STACK ) Create a config for a displacement workflow. Source code in dolphin/workflows/_config_cli.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def create_config ( * , outfile : Union [ str , Path ], slc_directory = None , ext : str = \".nc\" , slc_files : Optional [ List [ str ]] = None , mask_files : Optional [ List [ str ]] = None , name : WorkflowName = WorkflowName . STACK , ): \"\"\"Create a config for a displacement workflow.\"\"\" cfg = Config ( inputs = { \"cslc_directory\" : slc_directory , \"cslc_file_ext\" : ext , \"cslc_file_list\" : slc_files , \"mask_files\" : mask_files , }, name = name , ) if outfile == \"-\" : # Write to stdout cfg . to_yaml ( sys . stdout ) else : print ( f \"Saving configuration to { str ( outfile ) } \" , file = sys . stderr ) cfg . to_yaml ( outfile ) get_parser ( subparser = None , subcommand_name = 'run' ) Set up the command line interface. Source code in dolphin/workflows/_config_cli.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def get_parser ( subparser = None , subcommand_name = \"run\" ): \"\"\"Set up the command line interface.\"\"\" metadata = dict ( description = \"Create a configuration file for a displacement workflow.\" , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) if subparser : # Used by the subparser to make a nested command line interface parser = subparser . add_parser ( subcommand_name , ** metadata ) else : parser = argparse . ArgumentParser ( ** metadata ) parser . add_argument ( \"-o\" , \"--outfile\" , default = \"dolphin_config.yaml\" , help = \"Name of YAML configuration file to save to. Use '-' to write to stdout.\" , ) # Get Inputs from the command line parser . add_argument ( \"-d\" , \"--slc-directory\" , help = \"Path to directory containing the SLCs.\" , ) parser . add_argument ( \"--ext\" , default = \".nc\" , help = \"Extension of SLCs to search for (if --slc-directory is given).\" , ) parser . add_argument ( \"--slc-files\" , nargs = argparse . ZERO_OR_MORE , help = \"Alternative: list the paths of all SLC files to include.\" , ) parser . add_argument ( \"-n\" , \"--name\" , type = str . lower , choices = [ i . name . lower () for i in WorkflowName ], default = WorkflowName . STACK . value , help = \"Name of the displacement workflow. YAML configuration file to save to.\" , ) parser . add_argument ( \"--mask-files\" , nargs = argparse . ZERO_OR_MORE , help = \"Path to a file containing a list of mask files.\" , ) parser . set_defaults ( run_func = create_config ) return parser main ( args = None ) Get the command line arguments and create the config file. Source code in dolphin/workflows/_config_cli.py 90 91 92 93 94 def main ( args = None ): \"\"\"Get the command line arguments and create the config file.\"\"\" parser = get_parser () parsed_args = parser . parse_args ( args ) create_config ( ** vars ( parsed_args ))","title":"_config_cli"},{"location":"reference/dolphin/workflows/_config_cli/#dolphin.workflows._config_cli.create_config","text":"Create a config for a displacement workflow. Source code in dolphin/workflows/_config_cli.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def create_config ( * , outfile : Union [ str , Path ], slc_directory = None , ext : str = \".nc\" , slc_files : Optional [ List [ str ]] = None , mask_files : Optional [ List [ str ]] = None , name : WorkflowName = WorkflowName . STACK , ): \"\"\"Create a config for a displacement workflow.\"\"\" cfg = Config ( inputs = { \"cslc_directory\" : slc_directory , \"cslc_file_ext\" : ext , \"cslc_file_list\" : slc_files , \"mask_files\" : mask_files , }, name = name , ) if outfile == \"-\" : # Write to stdout cfg . to_yaml ( sys . stdout ) else : print ( f \"Saving configuration to { str ( outfile ) } \" , file = sys . stderr ) cfg . to_yaml ( outfile )","title":"create_config()"},{"location":"reference/dolphin/workflows/_config_cli/#dolphin.workflows._config_cli.get_parser","text":"Set up the command line interface. Source code in dolphin/workflows/_config_cli.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def get_parser ( subparser = None , subcommand_name = \"run\" ): \"\"\"Set up the command line interface.\"\"\" metadata = dict ( description = \"Create a configuration file for a displacement workflow.\" , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) if subparser : # Used by the subparser to make a nested command line interface parser = subparser . add_parser ( subcommand_name , ** metadata ) else : parser = argparse . ArgumentParser ( ** metadata ) parser . add_argument ( \"-o\" , \"--outfile\" , default = \"dolphin_config.yaml\" , help = \"Name of YAML configuration file to save to. Use '-' to write to stdout.\" , ) # Get Inputs from the command line parser . add_argument ( \"-d\" , \"--slc-directory\" , help = \"Path to directory containing the SLCs.\" , ) parser . add_argument ( \"--ext\" , default = \".nc\" , help = \"Extension of SLCs to search for (if --slc-directory is given).\" , ) parser . add_argument ( \"--slc-files\" , nargs = argparse . ZERO_OR_MORE , help = \"Alternative: list the paths of all SLC files to include.\" , ) parser . add_argument ( \"-n\" , \"--name\" , type = str . lower , choices = [ i . name . lower () for i in WorkflowName ], default = WorkflowName . STACK . value , help = \"Name of the displacement workflow. YAML configuration file to save to.\" , ) parser . add_argument ( \"--mask-files\" , nargs = argparse . ZERO_OR_MORE , help = \"Path to a file containing a list of mask files.\" , ) parser . set_defaults ( run_func = create_config ) return parser","title":"get_parser()"},{"location":"reference/dolphin/workflows/_config_cli/#dolphin.workflows._config_cli.main","text":"Get the command line arguments and create the config file. Source code in dolphin/workflows/_config_cli.py 90 91 92 93 94 def main ( args = None ): \"\"\"Get the command line arguments and create the config file.\"\"\" parser = get_parser () parsed_args = parser . parse_args ( args ) create_config ( ** vars ( parsed_args ))","title":"main()"},{"location":"reference/dolphin/workflows/_enums/","text":"InterferogramNetworkType Bases: str , Enum Types of interferogram networks. Source code in dolphin/workflows/_enums.py 34 35 36 37 38 39 class InterferogramNetworkType ( str , Enum ): \"\"\"Types of interferogram networks.\"\"\" SINGLE_REFERENCE = \"single-reference\" MAX_BANDWIDTH = \"max-bandwidth\" MAX_TEMPORAL_BASELINE = \"max-temporal-baseline\" OutputFormat Bases: str , Enum Possible output formats for the workflow. Source code in dolphin/workflows/_enums.py 18 19 20 21 22 23 24 class OutputFormat ( str , Enum ): \"\"\"Possible output formats for the workflow.\"\"\" ENVI = \"ENVI\" GTiff = \"GTiff\" HDF5 = \"HDF5\" NETCDF = \"NetCDF\" UnwrapMethod Bases: str , Enum Methods passable to Tophu unwrapping functions. Source code in dolphin/workflows/_enums.py 27 28 29 30 31 class UnwrapMethod ( str , Enum ): \"\"\"Methods passable to Tophu unwrapping functions.\"\"\" SNAPHU = \"snaphu\" ICU = \"icu\" WorkflowName Bases: str , Enum Names of workflows. Source code in dolphin/workflows/_enums.py 11 12 13 14 15 class WorkflowName ( str , Enum ): \"\"\"Names of workflows.\"\"\" STACK = \"stack\" SINGLE = \"single\"","title":"_enums"},{"location":"reference/dolphin/workflows/_enums/#dolphin.workflows._enums.InterferogramNetworkType","text":"Bases: str , Enum Types of interferogram networks. Source code in dolphin/workflows/_enums.py 34 35 36 37 38 39 class InterferogramNetworkType ( str , Enum ): \"\"\"Types of interferogram networks.\"\"\" SINGLE_REFERENCE = \"single-reference\" MAX_BANDWIDTH = \"max-bandwidth\" MAX_TEMPORAL_BASELINE = \"max-temporal-baseline\"","title":"InterferogramNetworkType"},{"location":"reference/dolphin/workflows/_enums/#dolphin.workflows._enums.OutputFormat","text":"Bases: str , Enum Possible output formats for the workflow. Source code in dolphin/workflows/_enums.py 18 19 20 21 22 23 24 class OutputFormat ( str , Enum ): \"\"\"Possible output formats for the workflow.\"\"\" ENVI = \"ENVI\" GTiff = \"GTiff\" HDF5 = \"HDF5\" NETCDF = \"NetCDF\"","title":"OutputFormat"},{"location":"reference/dolphin/workflows/_enums/#dolphin.workflows._enums.UnwrapMethod","text":"Bases: str , Enum Methods passable to Tophu unwrapping functions. Source code in dolphin/workflows/_enums.py 27 28 29 30 31 class UnwrapMethod ( str , Enum ): \"\"\"Methods passable to Tophu unwrapping functions.\"\"\" SNAPHU = \"snaphu\" ICU = \"icu\"","title":"UnwrapMethod"},{"location":"reference/dolphin/workflows/_enums/#dolphin.workflows._enums.WorkflowName","text":"Bases: str , Enum Names of workflows. Source code in dolphin/workflows/_enums.py 11 12 13 14 15 class WorkflowName ( str , Enum ): \"\"\"Names of workflows.\"\"\" STACK = \"stack\" SINGLE = \"single\"","title":"WorkflowName"},{"location":"reference/dolphin/workflows/_run_cli/","text":"get_parser ( subparser = None , subcommand_name = 'run' ) Set up the command line interface. Source code in dolphin/workflows/_run_cli.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_parser ( subparser = None , subcommand_name = \"run\" ): \"\"\"Set up the command line interface.\"\"\" metadata = dict ( description = \"Run a displacement workflow\" , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) if subparser : # Used by the subparser to make a nested command line interface parser = subparser . add_parser ( subcommand_name , ** metadata ) else : parser = argparse . ArgumentParser ( ** metadata ) parser . add_argument ( \"config_file\" , help = \"Name of YAML configuration file describing workflow options.\" , ) parser . add_argument ( \"-n\" , \"--name\" , default = \"stack\" , choices = [ \"single\" , \"stack\" ], help = \"Name workflow to run.\" , ) parser . add_argument ( \"--debug\" , action = \"store_true\" , help = \"Print debug messages to the log.\" , ) return parser main ( args = None ) Get the command line arguments and run the workflow. Source code in dolphin/workflows/_run_cli.py 66 67 68 69 70 def main ( args = None ): \"\"\"Get the command line arguments and run the workflow.\"\"\" parser = get_parser () parsed_args = parser . parse_args ( args ) run ( parsed_args . config_file , name = parsed_args . name , debug = parsed_args . debug ) run ( config_file , debug = False ) Run the displacement workflow. Parameters: Name Type Description Default config_file str YAML file containing the workflow options. required debug bool , optional Enable debug logging, by default False. False Source code in dolphin/workflows/_run_cli.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @log_runtime def run ( config_file : str , debug : bool = False ): \"\"\"Run the displacement workflow. Parameters ---------- config_file : str YAML file containing the workflow options. debug : bool, optional Enable debug logging, by default False. \"\"\" cfg = Config . from_yaml ( config_file ) if cfg . workflow_name == \"stack\" : from dolphin.workflows import s1_disp_stack s1_disp_stack . run ( cfg , debug = debug ) elif cfg . workflow_name == \"single\" : raise NotImplementedError ( \"Single interferogram workflow not yet implemented\" ) else : choices = WorkflowName . __members__ . values () raise ValueError ( f \"Unknown workflow name: { cfg . workflow_name } . Must be one of { choices } \" )","title":"_run_cli"},{"location":"reference/dolphin/workflows/_run_cli/#dolphin.workflows._run_cli.get_parser","text":"Set up the command line interface. Source code in dolphin/workflows/_run_cli.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_parser ( subparser = None , subcommand_name = \"run\" ): \"\"\"Set up the command line interface.\"\"\" metadata = dict ( description = \"Run a displacement workflow\" , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) if subparser : # Used by the subparser to make a nested command line interface parser = subparser . add_parser ( subcommand_name , ** metadata ) else : parser = argparse . ArgumentParser ( ** metadata ) parser . add_argument ( \"config_file\" , help = \"Name of YAML configuration file describing workflow options.\" , ) parser . add_argument ( \"-n\" , \"--name\" , default = \"stack\" , choices = [ \"single\" , \"stack\" ], help = \"Name workflow to run.\" , ) parser . add_argument ( \"--debug\" , action = \"store_true\" , help = \"Print debug messages to the log.\" , ) return parser","title":"get_parser()"},{"location":"reference/dolphin/workflows/_run_cli/#dolphin.workflows._run_cli.main","text":"Get the command line arguments and run the workflow. Source code in dolphin/workflows/_run_cli.py 66 67 68 69 70 def main ( args = None ): \"\"\"Get the command line arguments and run the workflow.\"\"\" parser = get_parser () parsed_args = parser . parse_args ( args ) run ( parsed_args . config_file , name = parsed_args . name , debug = parsed_args . debug )","title":"main()"},{"location":"reference/dolphin/workflows/_run_cli/#dolphin.workflows._run_cli.run","text":"Run the displacement workflow. Parameters: Name Type Description Default config_file str YAML file containing the workflow options. required debug bool , optional Enable debug logging, by default False. False Source code in dolphin/workflows/_run_cli.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @log_runtime def run ( config_file : str , debug : bool = False ): \"\"\"Run the displacement workflow. Parameters ---------- config_file : str YAML file containing the workflow options. debug : bool, optional Enable debug logging, by default False. \"\"\" cfg = Config . from_yaml ( config_file ) if cfg . workflow_name == \"stack\" : from dolphin.workflows import s1_disp_stack s1_disp_stack . run ( cfg , debug = debug ) elif cfg . workflow_name == \"single\" : raise NotImplementedError ( \"Single interferogram workflow not yet implemented\" ) else : choices = WorkflowName . __members__ . values () raise ValueError ( f \"Unknown workflow name: { cfg . workflow_name } . Must be one of { choices } \" )","title":"run()"},{"location":"reference/dolphin/workflows/config/","text":"Config Bases: BaseModel Configuration for the workflow. Required fields are in Inputs . Must specify either cslc_file_list , or cslc_directory and a cslc_file_ext . Source code in dolphin/workflows/config.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 class Config ( BaseModel ): \"\"\"Configuration for the workflow. Required fields are in `Inputs`. Must specify either `cslc_file_list`, or `cslc_directory` and a `cslc_file_ext`. \"\"\" workflow_name : str = WorkflowName . STACK inputs : Inputs outputs : Outputs = Field ( default_factory = Outputs ) # Options for each step in the workflow ps_options : PsOptions = Field ( default_factory = PsOptions ) phase_linking : PhaseLinkingOptions = Field ( default_factory = PhaseLinkingOptions ) interferogram_network : InterferogramNetwork = Field ( default_factory = InterferogramNetwork ) unwrap_options : UnwrapOptions = Field ( default_factory = UnwrapOptions ) # General workflow metadata worker_settings : WorkerSettings = Field ( default_factory = WorkerSettings ) creation_time_utc : datetime = Field ( default_factory = datetime . utcnow ) dolphin_version : str = _dolphin_version # validators @root_validator def _move_dirs_inside_scratch ( cls , values ): \"\"\"Ensure outputs from workflow steps are within scratch directory.\"\"\" scratch_dir = values [ \"outputs\" ] . scratch_directory # For each workflow step that has an output folder, move it inside # the scratch directory (if it's not already inside). # They may already be inside if we're loading from a json/yaml file. ps_opts = values [ \"ps_options\" ] if not ps_opts . directory . parent == scratch_dir : values [ \"ps_options\" ] . directory = scratch_dir / ps_opts . directory if not ps_opts . amp_dispersion_file . parent . parent == scratch_dir : values [ \"ps_options\" ] . amp_dispersion_file = ( scratch_dir / ps_opts . amp_dispersion_file ) if not ps_opts . amp_mean_file . parent . parent == scratch_dir : values [ \"ps_options\" ] . amp_mean_file = scratch_dir / ps_opts . amp_mean_file if not ps_opts . output_file . parent . parent == scratch_dir : values [ \"ps_options\" ] . output_file = scratch_dir / ps_opts . output_file pl_opts = values [ \"phase_linking\" ] if not pl_opts . directory . parent == scratch_dir : values [ \"phase_linking\" ] . directory = scratch_dir / pl_opts . directory if not pl_opts . compressed_slc_file . parent . parent == scratch_dir : values [ \"phase_linking\" ] . compressed_slc_file = ( scratch_dir / pl_opts . compressed_slc_file ) if not pl_opts . temp_coh_file . parent . parent == scratch_dir : values [ \"phase_linking\" ] . temp_coh_file = scratch_dir / pl_opts . temp_coh_file unw_opts = values [ \"unwrap_options\" ] if not unw_opts . directory . parent == scratch_dir : values [ \"unwrap_options\" ] . directory = scratch_dir / unw_opts . directory return values # Extra model exporting options beyond .dict() or .json() def to_yaml ( self , output_path : Union [ PathOrStr , TextIO ]): \"\"\"Save workflow configuration as a yaml file. Used to record the default-filled version of a supplied yaml. Parameters ---------- output_path : Pathlike Path to the yaml file to save. \"\"\" data = json . loads ( self . json ()) y = YAML () if hasattr ( output_path , \"write\" ): y . dump ( data , output_path ) else : with open ( output_path , \"w\" ) as f : y . dump ( data , f ) @classmethod def from_yaml ( cls , yaml_path : PathOrStr ): \"\"\"Load a workflow configuration from a yaml file. Parameters ---------- yaml_path : Pathlike Path to the yaml file to load. Returns ------- Config Workflow configuration \"\"\" y = YAML ( typ = \"safe\" ) with open ( yaml_path , \"r\" ) as f : data = y . load ( f ) return cls ( ** data ) from_yaml ( yaml_path ) classmethod Load a workflow configuration from a yaml file. Parameters: Name Type Description Default yaml_path Pathlike Path to the yaml file to load. required Returns: Type Description Config Workflow configuration Source code in dolphin/workflows/config.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 @classmethod def from_yaml ( cls , yaml_path : PathOrStr ): \"\"\"Load a workflow configuration from a yaml file. Parameters ---------- yaml_path : Pathlike Path to the yaml file to load. Returns ------- Config Workflow configuration \"\"\" y = YAML ( typ = \"safe\" ) with open ( yaml_path , \"r\" ) as f : data = y . load ( f ) return cls ( ** data ) to_yaml ( output_path ) Save workflow configuration as a yaml file. Used to record the default-filled version of a supplied yaml. Parameters: Name Type Description Default output_path Pathlike Path to the yaml file to save. required Source code in dolphin/workflows/config.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def to_yaml ( self , output_path : Union [ PathOrStr , TextIO ]): \"\"\"Save workflow configuration as a yaml file. Used to record the default-filled version of a supplied yaml. Parameters ---------- output_path : Pathlike Path to the yaml file to save. \"\"\" data = json . loads ( self . json ()) y = YAML () if hasattr ( output_path , \"write\" ): y . dump ( data , output_path ) else : with open ( output_path , \"w\" ) as f : y . dump ( data , f ) HalfWindow Bases: BaseModel Class to hold half-window size for multi-looking during phase linking. Source code in dolphin/workflows/config.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class HalfWindow ( BaseModel ): \"\"\"Class to hold half-window size for multi-looking during phase linking.\"\"\" x : int = Field ( 11 , description = \"Half window size (in pixels) for x direction\" , gt = 0 ) y : int = Field ( 5 , description = \"Half window size (in pixels) for y direction\" , gt = 0 ) def to_looks ( self ): \"\"\"Convert (x, y) half-window size to (row, column) looks.\"\"\" return 2 * self . y + 1 , 2 * self . x + 1 @classmethod def from_looks ( cls , row_looks : int , col_looks : int ): \"\"\"Create a half-window from looks.\"\"\" return cls ( x = col_looks // 2 , y = row_looks // 2 ) from_looks ( row_looks , col_looks ) classmethod Create a half-window from looks. Source code in dolphin/workflows/config.py 88 89 90 91 @classmethod def from_looks ( cls , row_looks : int , col_looks : int ): \"\"\"Create a half-window from looks.\"\"\" return cls ( x = col_looks // 2 , y = row_looks // 2 ) to_looks () Convert (x, y) half-window size to (row, column) looks. Source code in dolphin/workflows/config.py 84 85 86 def to_looks ( self ): \"\"\"Convert (x, y) half-window size to (row, column) looks.\"\"\" return 2 * self . y + 1 , 2 * self . x + 1 Inputs Bases: BaseModel Options specifying input datasets for workflow. Source code in dolphin/workflows/config.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 class Inputs ( BaseModel ): \"\"\"Options specifying input datasets for workflow.\"\"\" cslc_file_list : List [ PathOrStr ] = Field ( default_factory = list , description = \"List of CSLC files\" ) cslc_directory : DirectoryPath = Field ( None , description = \"Path to CSLC files\" ) cslc_file_ext : Optional [ str ] = Field ( \".nc\" , description = \"Extension of CSLC files (if providing `cslc_directory`)\" , ) cslc_date_fmt : str = Field ( \"%Y%m %d \" , description = \"Format of dates contained in CSLC filenames\" , ) mask_files : List [ str ] = Field ( default_factory = list , description = ( \"List of mask files to use, where convention is\" \" 0 for no data/invalid, and 1 for data.\" ), ) # validators @validator ( \"mask_files\" , \"cslc_file_list\" , pre = True ) def _check_mask_files ( cls , v ): if isinstance ( v , str ): return [ v ] elif v is None : return [] return v @root_validator def _check_slc_files_exist ( cls , values ): file_list = values . get ( \"cslc_file_list\" ) directory = values . get ( \"cslc_directory\" ) if not file_list : if not directory : raise ValueError ( \"Must specify either cslc_file_list or cslc_directory\" ) ext = values . get ( \"cslc_file_ext\" ) file_list = sorted ( directory . glob ( f \"* { ext } \" )) # Filter out files that don't have dates in the filename date_fmt = values . get ( \"cslc_date_fmt\" ) file_list = [ str ( f ) for f in file_list if get_dates ( f , fmt = date_fmt )] values [ \"cslc_file_list\" ] = file_list return values InterferogramNetwork Bases: BaseModel Options to determine the type of network for interferogram formation. Source code in dolphin/workflows/config.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class InterferogramNetwork ( BaseModel ): \"\"\"Options to determine the type of network for interferogram formation.\"\"\" reference_idx : Optional [ int ] = Field ( None , description = ( \"For single-reference network: Index of the reference image in the network\" ), ) max_bandwidth : Optional [ int ] = Field ( None , description = \"Max `n` to form the nearest-`n` interferograms by index.\" , gt = 1 , ) max_temporal_baseline : Optional [ int ] = Field ( None , description = \"Maximum temporal baseline of interferograms\" , gt = 0 , ) network_type = InterferogramNetworkType . SINGLE_REFERENCE # validation @root_validator def _check_network_type ( cls , values ): ref_idx = values . get ( \"reference_idx\" ) max_bw = values . get ( \"max_bandwidth\" ) max_tb = values . get ( \"max_temporal_baseline\" ) # Check if more than one has been set: if sum ([ ref_idx is not None , max_bw is not None , max_tb is not None ]) > 1 : raise ValueError ( \"Only one of `reference_idx`, `max_bandwidth`, or\" \" `max_temporal_baseline` can be set.\" ) if max_tb is not None : values [ \"network_type\" ] = InterferogramNetworkType . TEMPORAL_BASELINE return values if max_bw is not None : values [ \"network_type\" ] = InterferogramNetworkType . BANDWIDTH return values # If nothing else specified, set to a single reference network values [ \"network_type\" ] = InterferogramNetworkType . SINGLE_REFERENCE # and make sure the reference index is set if ref_idx is None : values [ \"reference_idx\" ] = 0 return values Outputs Bases: BaseModel Options for the output format/compressions. Source code in dolphin/workflows/config.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 class Outputs ( BaseModel ): \"\"\"Options for the output format/compressions.\"\"\" output_format : OutputFormat = OutputFormat . NETCDF scratch_directory : Path = Path ( \"scratch\" ) # TODO: spacing, strides, etc. output_directory : Path = Path ( \"output\" ) hdf5_creation_options : Dict = Field ( dict ( chunks = True , compression = \"gzip\" , compression_opts = 4 , shuffle = True , ), description = \"Options for `create_dataset` with h5py.\" , ) gtiff_creation_options : List [ str ] = Field ( [ \"TILED=YES\" , \"COMPRESS=DEFLATE\" , \"ZLEVEL=5\" ], description = \"GDAL creation options for GeoTIFF files\" , ) # validators _dir_must_exist = validator ( \"output_directory\" , \"scratch_directory\" , allow_reuse = True , always = True )( _check_and_make_dir ) PhaseLinkingOptions Bases: BaseModel Configurable options for wrapped phase estimation. Source code in dolphin/workflows/config.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class PhaseLinkingOptions ( BaseModel ): \"\"\"Configurable options for wrapped phase estimation.\"\"\" directory : Path = Path ( \"linked_phase\" ) ministack_size : int = Field ( 15 , description = \"Size of the ministack for sequential estimator.\" , gt = 1 ) half_window = HalfWindow () compressed_slc_file : Path = Path ( \"compressed_slc.tif\" ) temp_coh_file : Path = Path ( \"temp_coh.tif\" ) # validators _dir_must_exist = validator ( \"directory\" , allow_reuse = True , always = True )( _check_and_make_dir ) _move_in_dir = validator ( \"compressed_slc_file\" , \"temp_coh_file\" , allow_reuse = True , always = True )( _move_file_in_dir ) @staticmethod def _format_date_pair ( start : date , end : date , fmt = \"%Y%m %d \" ) -> str : return f \" { start . strftime ( fmt ) } _ { end . strftime ( fmt ) } \" PsOptions Bases: BaseModel Options for the PS pixel selection portion of the workflow. Source code in dolphin/workflows/config.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class PsOptions ( BaseModel ): \"\"\"Options for the PS pixel selection portion of the workflow.\"\"\" directory : Path = Path ( \"PS\" ) output_file : Optional [ Path ] = Path ( \"ps_pixels.tif\" ) amp_dispersion_file : Optional [ Path ] = Path ( \"amp_dispersion.tif\" ) amp_mean_file : Optional [ Path ] = Path ( \"amp_mean.tif\" ) amp_dispersion_threshold : float = Field ( 0.42 , description = \"Amplitude dispersion threshold to consider a pixel a PS.\" , gt = 0.0 , ) # validators: Check directory exists, and that outputs are within directory _dir_must_exist = validator ( \"directory\" , allow_reuse = True , always = True )( _check_and_make_dir ) _move_in_dir = validator ( \"output_file\" , \"amp_dispersion_file\" , \"amp_mean_file\" , always = True , allow_reuse = True , )( _move_file_in_dir ) UnwrapOptions Bases: BaseModel Options for unwrapping after wrapped phase estimation. Source code in dolphin/workflows/config.py 167 168 169 170 171 172 173 174 175 176 177 178 179 class UnwrapOptions ( BaseModel ): \"\"\"Options for unwrapping after wrapped phase estimation.\"\"\" run_unwrap : bool = False directory : Path = Path ( \"unwrap\" ) unwrap_method : UnwrapMethod = UnwrapMethod . SNAPHU tiles : Sequence [ int ] = [ 1 , 1 ] init_method : str = \"mcf\" # validators _dir_must_exist = validator ( \"directory\" , allow_reuse = True , always = True )( _check_and_make_dir ) WorkerSettings Bases: BaseSettings Settings configurable based on environment variables. Source code in dolphin/workflows/config.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class WorkerSettings ( BaseSettings ): \"\"\"Settings configurable based on environment variables.\"\"\" gpu_enabled : bool = Field ( True , description = \"Whether to use GPU for processing (if available)\" , ) gpu_id : int = Field ( 0 , description = \"Index of the GPU to use for processing (if GPU)\" , ) # n_workers: int = PositiveInt(16) n_workers : int = Field ( 16 , ge = 1 , description = \"Number of cpu cores to use for processing (if CPU)\" ) max_ram_gb : float = Field ( 1.0 , description = \"Maximum RAM (in GB) to use for processing\" , gt = 0.1 , ) class Config : \"\"\"Pydantic class configuration for BaseSettings.\"\"\" # https://docs.pydantic.dev/usage/settings/#parsing-environment-variable-values env_prefix = \"dolphin_\" # e.g. DOLPHIN_N_WORKERS=4 for n_workers fields = { \"gpu_enabled\" : { \"env\" : [ \"dolphin_gpu_enabled\" , \"gpu\" ]}, } Config Pydantic class configuration for BaseSettings. Source code in dolphin/workflows/config.py 203 204 205 206 207 208 209 210 class Config : \"\"\"Pydantic class configuration for BaseSettings.\"\"\" # https://docs.pydantic.dev/usage/settings/#parsing-environment-variable-values env_prefix = \"dolphin_\" # e.g. DOLPHIN_N_WORKERS=4 for n_workers fields = { \"gpu_enabled\" : { \"env\" : [ \"dolphin_gpu_enabled\" , \"gpu\" ]}, }","title":"config"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.Config","text":"Bases: BaseModel Configuration for the workflow. Required fields are in Inputs . Must specify either cslc_file_list , or cslc_directory and a cslc_file_ext . Source code in dolphin/workflows/config.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 class Config ( BaseModel ): \"\"\"Configuration for the workflow. Required fields are in `Inputs`. Must specify either `cslc_file_list`, or `cslc_directory` and a `cslc_file_ext`. \"\"\" workflow_name : str = WorkflowName . STACK inputs : Inputs outputs : Outputs = Field ( default_factory = Outputs ) # Options for each step in the workflow ps_options : PsOptions = Field ( default_factory = PsOptions ) phase_linking : PhaseLinkingOptions = Field ( default_factory = PhaseLinkingOptions ) interferogram_network : InterferogramNetwork = Field ( default_factory = InterferogramNetwork ) unwrap_options : UnwrapOptions = Field ( default_factory = UnwrapOptions ) # General workflow metadata worker_settings : WorkerSettings = Field ( default_factory = WorkerSettings ) creation_time_utc : datetime = Field ( default_factory = datetime . utcnow ) dolphin_version : str = _dolphin_version # validators @root_validator def _move_dirs_inside_scratch ( cls , values ): \"\"\"Ensure outputs from workflow steps are within scratch directory.\"\"\" scratch_dir = values [ \"outputs\" ] . scratch_directory # For each workflow step that has an output folder, move it inside # the scratch directory (if it's not already inside). # They may already be inside if we're loading from a json/yaml file. ps_opts = values [ \"ps_options\" ] if not ps_opts . directory . parent == scratch_dir : values [ \"ps_options\" ] . directory = scratch_dir / ps_opts . directory if not ps_opts . amp_dispersion_file . parent . parent == scratch_dir : values [ \"ps_options\" ] . amp_dispersion_file = ( scratch_dir / ps_opts . amp_dispersion_file ) if not ps_opts . amp_mean_file . parent . parent == scratch_dir : values [ \"ps_options\" ] . amp_mean_file = scratch_dir / ps_opts . amp_mean_file if not ps_opts . output_file . parent . parent == scratch_dir : values [ \"ps_options\" ] . output_file = scratch_dir / ps_opts . output_file pl_opts = values [ \"phase_linking\" ] if not pl_opts . directory . parent == scratch_dir : values [ \"phase_linking\" ] . directory = scratch_dir / pl_opts . directory if not pl_opts . compressed_slc_file . parent . parent == scratch_dir : values [ \"phase_linking\" ] . compressed_slc_file = ( scratch_dir / pl_opts . compressed_slc_file ) if not pl_opts . temp_coh_file . parent . parent == scratch_dir : values [ \"phase_linking\" ] . temp_coh_file = scratch_dir / pl_opts . temp_coh_file unw_opts = values [ \"unwrap_options\" ] if not unw_opts . directory . parent == scratch_dir : values [ \"unwrap_options\" ] . directory = scratch_dir / unw_opts . directory return values # Extra model exporting options beyond .dict() or .json() def to_yaml ( self , output_path : Union [ PathOrStr , TextIO ]): \"\"\"Save workflow configuration as a yaml file. Used to record the default-filled version of a supplied yaml. Parameters ---------- output_path : Pathlike Path to the yaml file to save. \"\"\" data = json . loads ( self . json ()) y = YAML () if hasattr ( output_path , \"write\" ): y . dump ( data , output_path ) else : with open ( output_path , \"w\" ) as f : y . dump ( data , f ) @classmethod def from_yaml ( cls , yaml_path : PathOrStr ): \"\"\"Load a workflow configuration from a yaml file. Parameters ---------- yaml_path : Pathlike Path to the yaml file to load. Returns ------- Config Workflow configuration \"\"\" y = YAML ( typ = \"safe\" ) with open ( yaml_path , \"r\" ) as f : data = y . load ( f ) return cls ( ** data )","title":"Config"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.Config.from_yaml","text":"Load a workflow configuration from a yaml file. Parameters: Name Type Description Default yaml_path Pathlike Path to the yaml file to load. required Returns: Type Description Config Workflow configuration Source code in dolphin/workflows/config.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 @classmethod def from_yaml ( cls , yaml_path : PathOrStr ): \"\"\"Load a workflow configuration from a yaml file. Parameters ---------- yaml_path : Pathlike Path to the yaml file to load. Returns ------- Config Workflow configuration \"\"\" y = YAML ( typ = \"safe\" ) with open ( yaml_path , \"r\" ) as f : data = y . load ( f ) return cls ( ** data )","title":"from_yaml()"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.Config.to_yaml","text":"Save workflow configuration as a yaml file. Used to record the default-filled version of a supplied yaml. Parameters: Name Type Description Default output_path Pathlike Path to the yaml file to save. required Source code in dolphin/workflows/config.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def to_yaml ( self , output_path : Union [ PathOrStr , TextIO ]): \"\"\"Save workflow configuration as a yaml file. Used to record the default-filled version of a supplied yaml. Parameters ---------- output_path : Pathlike Path to the yaml file to save. \"\"\" data = json . loads ( self . json ()) y = YAML () if hasattr ( output_path , \"write\" ): y . dump ( data , output_path ) else : with open ( output_path , \"w\" ) as f : y . dump ( data , f )","title":"to_yaml()"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.HalfWindow","text":"Bases: BaseModel Class to hold half-window size for multi-looking during phase linking. Source code in dolphin/workflows/config.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class HalfWindow ( BaseModel ): \"\"\"Class to hold half-window size for multi-looking during phase linking.\"\"\" x : int = Field ( 11 , description = \"Half window size (in pixels) for x direction\" , gt = 0 ) y : int = Field ( 5 , description = \"Half window size (in pixels) for y direction\" , gt = 0 ) def to_looks ( self ): \"\"\"Convert (x, y) half-window size to (row, column) looks.\"\"\" return 2 * self . y + 1 , 2 * self . x + 1 @classmethod def from_looks ( cls , row_looks : int , col_looks : int ): \"\"\"Create a half-window from looks.\"\"\" return cls ( x = col_looks // 2 , y = row_looks // 2 )","title":"HalfWindow"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.HalfWindow.from_looks","text":"Create a half-window from looks. Source code in dolphin/workflows/config.py 88 89 90 91 @classmethod def from_looks ( cls , row_looks : int , col_looks : int ): \"\"\"Create a half-window from looks.\"\"\" return cls ( x = col_looks // 2 , y = row_looks // 2 )","title":"from_looks()"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.HalfWindow.to_looks","text":"Convert (x, y) half-window size to (row, column) looks. Source code in dolphin/workflows/config.py 84 85 86 def to_looks ( self ): \"\"\"Convert (x, y) half-window size to (row, column) looks.\"\"\" return 2 * self . y + 1 , 2 * self . x + 1","title":"to_looks()"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.Inputs","text":"Bases: BaseModel Options specifying input datasets for workflow. Source code in dolphin/workflows/config.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 class Inputs ( BaseModel ): \"\"\"Options specifying input datasets for workflow.\"\"\" cslc_file_list : List [ PathOrStr ] = Field ( default_factory = list , description = \"List of CSLC files\" ) cslc_directory : DirectoryPath = Field ( None , description = \"Path to CSLC files\" ) cslc_file_ext : Optional [ str ] = Field ( \".nc\" , description = \"Extension of CSLC files (if providing `cslc_directory`)\" , ) cslc_date_fmt : str = Field ( \"%Y%m %d \" , description = \"Format of dates contained in CSLC filenames\" , ) mask_files : List [ str ] = Field ( default_factory = list , description = ( \"List of mask files to use, where convention is\" \" 0 for no data/invalid, and 1 for data.\" ), ) # validators @validator ( \"mask_files\" , \"cslc_file_list\" , pre = True ) def _check_mask_files ( cls , v ): if isinstance ( v , str ): return [ v ] elif v is None : return [] return v @root_validator def _check_slc_files_exist ( cls , values ): file_list = values . get ( \"cslc_file_list\" ) directory = values . get ( \"cslc_directory\" ) if not file_list : if not directory : raise ValueError ( \"Must specify either cslc_file_list or cslc_directory\" ) ext = values . get ( \"cslc_file_ext\" ) file_list = sorted ( directory . glob ( f \"* { ext } \" )) # Filter out files that don't have dates in the filename date_fmt = values . get ( \"cslc_date_fmt\" ) file_list = [ str ( f ) for f in file_list if get_dates ( f , fmt = date_fmt )] values [ \"cslc_file_list\" ] = file_list return values","title":"Inputs"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.InterferogramNetwork","text":"Bases: BaseModel Options to determine the type of network for interferogram formation. Source code in dolphin/workflows/config.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class InterferogramNetwork ( BaseModel ): \"\"\"Options to determine the type of network for interferogram formation.\"\"\" reference_idx : Optional [ int ] = Field ( None , description = ( \"For single-reference network: Index of the reference image in the network\" ), ) max_bandwidth : Optional [ int ] = Field ( None , description = \"Max `n` to form the nearest-`n` interferograms by index.\" , gt = 1 , ) max_temporal_baseline : Optional [ int ] = Field ( None , description = \"Maximum temporal baseline of interferograms\" , gt = 0 , ) network_type = InterferogramNetworkType . SINGLE_REFERENCE # validation @root_validator def _check_network_type ( cls , values ): ref_idx = values . get ( \"reference_idx\" ) max_bw = values . get ( \"max_bandwidth\" ) max_tb = values . get ( \"max_temporal_baseline\" ) # Check if more than one has been set: if sum ([ ref_idx is not None , max_bw is not None , max_tb is not None ]) > 1 : raise ValueError ( \"Only one of `reference_idx`, `max_bandwidth`, or\" \" `max_temporal_baseline` can be set.\" ) if max_tb is not None : values [ \"network_type\" ] = InterferogramNetworkType . TEMPORAL_BASELINE return values if max_bw is not None : values [ \"network_type\" ] = InterferogramNetworkType . BANDWIDTH return values # If nothing else specified, set to a single reference network values [ \"network_type\" ] = InterferogramNetworkType . SINGLE_REFERENCE # and make sure the reference index is set if ref_idx is None : values [ \"reference_idx\" ] = 0 return values","title":"InterferogramNetwork"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.Outputs","text":"Bases: BaseModel Options for the output format/compressions. Source code in dolphin/workflows/config.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 class Outputs ( BaseModel ): \"\"\"Options for the output format/compressions.\"\"\" output_format : OutputFormat = OutputFormat . NETCDF scratch_directory : Path = Path ( \"scratch\" ) # TODO: spacing, strides, etc. output_directory : Path = Path ( \"output\" ) hdf5_creation_options : Dict = Field ( dict ( chunks = True , compression = \"gzip\" , compression_opts = 4 , shuffle = True , ), description = \"Options for `create_dataset` with h5py.\" , ) gtiff_creation_options : List [ str ] = Field ( [ \"TILED=YES\" , \"COMPRESS=DEFLATE\" , \"ZLEVEL=5\" ], description = \"GDAL creation options for GeoTIFF files\" , ) # validators _dir_must_exist = validator ( \"output_directory\" , \"scratch_directory\" , allow_reuse = True , always = True )( _check_and_make_dir )","title":"Outputs"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.PhaseLinkingOptions","text":"Bases: BaseModel Configurable options for wrapped phase estimation. Source code in dolphin/workflows/config.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class PhaseLinkingOptions ( BaseModel ): \"\"\"Configurable options for wrapped phase estimation.\"\"\" directory : Path = Path ( \"linked_phase\" ) ministack_size : int = Field ( 15 , description = \"Size of the ministack for sequential estimator.\" , gt = 1 ) half_window = HalfWindow () compressed_slc_file : Path = Path ( \"compressed_slc.tif\" ) temp_coh_file : Path = Path ( \"temp_coh.tif\" ) # validators _dir_must_exist = validator ( \"directory\" , allow_reuse = True , always = True )( _check_and_make_dir ) _move_in_dir = validator ( \"compressed_slc_file\" , \"temp_coh_file\" , allow_reuse = True , always = True )( _move_file_in_dir ) @staticmethod def _format_date_pair ( start : date , end : date , fmt = \"%Y%m %d \" ) -> str : return f \" { start . strftime ( fmt ) } _ { end . strftime ( fmt ) } \"","title":"PhaseLinkingOptions"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.PsOptions","text":"Bases: BaseModel Options for the PS pixel selection portion of the workflow. Source code in dolphin/workflows/config.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class PsOptions ( BaseModel ): \"\"\"Options for the PS pixel selection portion of the workflow.\"\"\" directory : Path = Path ( \"PS\" ) output_file : Optional [ Path ] = Path ( \"ps_pixels.tif\" ) amp_dispersion_file : Optional [ Path ] = Path ( \"amp_dispersion.tif\" ) amp_mean_file : Optional [ Path ] = Path ( \"amp_mean.tif\" ) amp_dispersion_threshold : float = Field ( 0.42 , description = \"Amplitude dispersion threshold to consider a pixel a PS.\" , gt = 0.0 , ) # validators: Check directory exists, and that outputs are within directory _dir_must_exist = validator ( \"directory\" , allow_reuse = True , always = True )( _check_and_make_dir ) _move_in_dir = validator ( \"output_file\" , \"amp_dispersion_file\" , \"amp_mean_file\" , always = True , allow_reuse = True , )( _move_file_in_dir )","title":"PsOptions"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.UnwrapOptions","text":"Bases: BaseModel Options for unwrapping after wrapped phase estimation. Source code in dolphin/workflows/config.py 167 168 169 170 171 172 173 174 175 176 177 178 179 class UnwrapOptions ( BaseModel ): \"\"\"Options for unwrapping after wrapped phase estimation.\"\"\" run_unwrap : bool = False directory : Path = Path ( \"unwrap\" ) unwrap_method : UnwrapMethod = UnwrapMethod . SNAPHU tiles : Sequence [ int ] = [ 1 , 1 ] init_method : str = \"mcf\" # validators _dir_must_exist = validator ( \"directory\" , allow_reuse = True , always = True )( _check_and_make_dir )","title":"UnwrapOptions"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.WorkerSettings","text":"Bases: BaseSettings Settings configurable based on environment variables. Source code in dolphin/workflows/config.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class WorkerSettings ( BaseSettings ): \"\"\"Settings configurable based on environment variables.\"\"\" gpu_enabled : bool = Field ( True , description = \"Whether to use GPU for processing (if available)\" , ) gpu_id : int = Field ( 0 , description = \"Index of the GPU to use for processing (if GPU)\" , ) # n_workers: int = PositiveInt(16) n_workers : int = Field ( 16 , ge = 1 , description = \"Number of cpu cores to use for processing (if CPU)\" ) max_ram_gb : float = Field ( 1.0 , description = \"Maximum RAM (in GB) to use for processing\" , gt = 0.1 , ) class Config : \"\"\"Pydantic class configuration for BaseSettings.\"\"\" # https://docs.pydantic.dev/usage/settings/#parsing-environment-variable-values env_prefix = \"dolphin_\" # e.g. DOLPHIN_N_WORKERS=4 for n_workers fields = { \"gpu_enabled\" : { \"env\" : [ \"dolphin_gpu_enabled\" , \"gpu\" ]}, }","title":"WorkerSettings"},{"location":"reference/dolphin/workflows/config/#dolphin.workflows.config.WorkerSettings.Config","text":"Pydantic class configuration for BaseSettings. Source code in dolphin/workflows/config.py 203 204 205 206 207 208 209 210 class Config : \"\"\"Pydantic class configuration for BaseSettings.\"\"\" # https://docs.pydantic.dev/usage/settings/#parsing-environment-variable-values env_prefix = \"dolphin_\" # e.g. DOLPHIN_N_WORKERS=4 for n_workers fields = { \"gpu_enabled\" : { \"env\" : [ \"dolphin_gpu_enabled\" , \"gpu\" ]}, }","title":"Config"},{"location":"reference/dolphin/workflows/s1_disp_stack/","text":"run ( cfg , debug = False ) Run the displacement workflow on a stack of SLCs. Parameters: Name Type Description Default cfg Config dolphin.Config object with workflow parameters required debug bool , optional Enable debug logging, by default False. False Source code in dolphin/workflows/s1_disp_stack.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @log_runtime def run ( cfg : Config , debug : bool = False ): \"\"\"Run the displacement workflow on a stack of SLCs. Parameters ---------- cfg : Config [dolphin.Config][] object with workflow parameters debug : bool, optional Enable debug logging, by default False. \"\"\" logger = get_log ( debug = debug ) # output_dir = cfg.outputs.output_directory.absolute() # scratch_dir = cfg.outputs.scratch_directory input_file_list = cfg . inputs . cslc_file_list if not input_file_list : raise ValueError ( \"No input files found\" ) # ############################################# # 0. Make a VRT pointing to the input SLC files # ############################################# # slc_vrt_file = scratch_dir / \"slc_stack.vrt\" # vrt_stack = vrt.VRTStack(input_file_list, outfile=slc_vrt_file) # vrt_stack.write() # ############### # 1. PS selection # ############### ps_output = cfg . ps_options . ps_file if ps_output . exists (): logger . info ( f \"Skipping making existing PS file { ps_output } \" ) else : logger . info ( f \"Creating persistent scatterer file { ps_output } \" ) # ps.create_ps(cfg.ps_options) # ######################### # 2. phase linking/EVD step # ######################### pl_path = cfg . phase_linking . directory existing_files = list ( pl_path . glob ( \"*.h5\" )) # TODO: get ext from config if len ( existing_files ) > 0 : logger . info ( f \"Skipping EVD step, { len ( existing_files ) } files already exist\" ) else : logger . info ( f \"Running sequential EMI step in { pl_path } \" ) # pl_path = sequential.run_evd_sequential( ... ) # ################################################### # 3. Form interferograms from estimated wrapped phase # ################################################### # existing_ifgs = list(cfg.interferograms.directory.glob(\"*.int*\")) # if len(existing_ifgs) > 0: # logger.info(f\"Skipping interferogram step, {len(existing_ifgs)} exists\") # else: # logger.info(f\"Running interferogram formation \") # # The python MLE function handles the temp coh, and the PS phase insertion # # interferograms.form_ifgs( ... ) # ################################### # 4. Stitch and Unwrap interferograms # ################################### # TODO: will this be a separate workflow? # Or will we loop through all bursts, then stitch, then unwrap all here? if not cfg . unwrap_options . run_unwrap : logger . info ( \"Skipping unwrap step\" ) return","title":"s1_disp_stack"},{"location":"reference/dolphin/workflows/s1_disp_stack/#dolphin.workflows.s1_disp_stack.run","text":"Run the displacement workflow on a stack of SLCs. Parameters: Name Type Description Default cfg Config dolphin.Config object with workflow parameters required debug bool , optional Enable debug logging, by default False. False Source code in dolphin/workflows/s1_disp_stack.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @log_runtime def run ( cfg : Config , debug : bool = False ): \"\"\"Run the displacement workflow on a stack of SLCs. Parameters ---------- cfg : Config [dolphin.Config][] object with workflow parameters debug : bool, optional Enable debug logging, by default False. \"\"\" logger = get_log ( debug = debug ) # output_dir = cfg.outputs.output_directory.absolute() # scratch_dir = cfg.outputs.scratch_directory input_file_list = cfg . inputs . cslc_file_list if not input_file_list : raise ValueError ( \"No input files found\" ) # ############################################# # 0. Make a VRT pointing to the input SLC files # ############################################# # slc_vrt_file = scratch_dir / \"slc_stack.vrt\" # vrt_stack = vrt.VRTStack(input_file_list, outfile=slc_vrt_file) # vrt_stack.write() # ############### # 1. PS selection # ############### ps_output = cfg . ps_options . ps_file if ps_output . exists (): logger . info ( f \"Skipping making existing PS file { ps_output } \" ) else : logger . info ( f \"Creating persistent scatterer file { ps_output } \" ) # ps.create_ps(cfg.ps_options) # ######################### # 2. phase linking/EVD step # ######################### pl_path = cfg . phase_linking . directory existing_files = list ( pl_path . glob ( \"*.h5\" )) # TODO: get ext from config if len ( existing_files ) > 0 : logger . info ( f \"Skipping EVD step, { len ( existing_files ) } files already exist\" ) else : logger . info ( f \"Running sequential EMI step in { pl_path } \" ) # pl_path = sequential.run_evd_sequential( ... ) # ################################################### # 3. Form interferograms from estimated wrapped phase # ################################################### # existing_ifgs = list(cfg.interferograms.directory.glob(\"*.int*\")) # if len(existing_ifgs) > 0: # logger.info(f\"Skipping interferogram step, {len(existing_ifgs)} exists\") # else: # logger.info(f\"Running interferogram formation \") # # The python MLE function handles the temp coh, and the PS phase insertion # # interferograms.form_ifgs( ... ) # ################################### # 4. Stitch and Unwrap interferograms # ################################### # TODO: will this be a separate workflow? # Or will we loop through all bursts, then stitch, then unwrap all here? if not cfg . unwrap_options . run_unwrap : logger . info ( \"Skipping unwrap step\" ) return","title":"run()"}]}